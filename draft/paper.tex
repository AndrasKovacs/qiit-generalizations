%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[PL'18]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2018}{New York, NY, USA}
\acmYear{2018}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


%% ------------------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathpartir}
\usepackage{scalerel}
\usepackage{stmaryrd}
\usepackage{tikz-cd}


\newtheorem{notation}{Notation}

\input{abbrevs.tex}
\newcommand{\Lift}{\Uparrow}
\newcommand{\ToS}{\mathsf{ToS}}
\newcommand{\ext}{\triangleright}
\newcommand{\emptycon}{\scaleobj{.75}\bullet}
\newcommand{\Pii}{\Pi}
\newcommand{\appi}{\mathsf{app}}
\newcommand{\lami}{\mathsf{lam}}
\newcommand{\Pie}{\Pi^{\mathsf{ext}}}
\newcommand{\appe}{\mathsf{app^{ext}}}
\newcommand{\lame}{\mathsf{lam^{ext}}}
\newcommand{\Piinf}{\Pi^{\mathsf{inf}}}
\newcommand{\appinf}{\mathsf{app^{inf}}}
\newcommand{\laminf}{\mathsf{lam^{inf}}}
\newcommand{\appitt}{\mathop{{\scriptstyle @}}}
\newcommand{\Refl}{\mathsf{Refl}}
\newcommand{\IdU}{\mathsf{IdU}}
\newcommand{\ReflU}{\mathsf{ReflU}}
\newcommand{\Sig}{\mathsf{Sig}}
\newcommand{\ToSSig}{\mathsf{ToSSig}}
\newcommand{\Inductive}{\mathsf{Inductive}}
\newcommand{\Subtype}{\mathsf{Subtype}}
\newcommand{\subtype}{\mathsf{subtype}}
\newcommand{\NatSig}{\mathsf{NatSig}}

\newcommand{\Sg}{\Sigma}
\newcommand{\flCwF}{\mathsf{flCwF}}
\newcommand{\Kfam}{\mathsf{K}}
\newcommand{\p}{\mathsf{p}}
\newcommand{\q}{\mathsf{q}}
\newcommand{\lamK}{\mathsf{lam}^{\K}}
\newcommand{\appK}{\mathsf{app}^{\K}}

\newcommand{\arri}{\Rightarrow}
\newcommand{\arre}{\Rightarrow^{\mathsf{ext}}}
\newcommand{\arrinf}{\Rightarrow^{\mathsf{inf}}}
\newcommand{\syn}{\mathsf{syn}}
\newcommand{\SynSig}{\mathsf{SynSig}}

\newcommand{\bCon}{\boldsymbol{\Con}}
\newcommand{\bTy}{\boldsymbol{\Ty}}
\newcommand{\bSub}{\boldsymbol{\Sub}}
\newcommand{\bTm}{\boldsymbol{\Tm}}
\newcommand{\bGamma}{\boldsymbol{\Gamma}}
\newcommand{\bDelta}{\boldsymbol{\Delta}}
\newcommand{\bsigma}{\boldsymbol{\sigma}}
\newcommand{\bdelta}{\boldsymbol{\delta}}
\newcommand{\bepsilon}{\boldsymbol{\epsilon}}
\newcommand{\bt}{\boldsymbol{t}}
\newcommand{\bu}{\boldsymbol{u}}
\newcommand{\bA}{\boldsymbol{A}}
\newcommand{\ba}{\boldsymbol{a}}
\newcommand{\bb}{\boldsymbol{b}}
\newcommand{\bB}{\boldsymbol{B}}
\newcommand{\bid}{\boldsymbol{\id}}
\newcommand{\bemptycon}{\boldsymbol{\emptycon}}
\newcommand{\bSet}{\boldsymbol{\Set}}
\newcommand{\bU}{\boldsymbol{\U}}
\newcommand{\bEl}{\boldsymbol{\El}}
\newcommand{\bPii}{\boldsymbol{\Pi}}
\newcommand{\bPie}{\boldsymbol{\Pie}}
\newcommand{\bPiinf}{\boldsymbol{\Piinf}}
\newcommand{\bappi}{\boldsymbol{\mathsf{app}}}
\newcommand{\blami}{\boldsymbol{\mathsf{lam}}}
\newcommand{\bId}{\boldsymbol{\Id}}
\newcommand{\bM}{\boldsymbol{\mathsf{M}}}
\newcommand{\bT}{\boldsymbol{\mathsf{T}}}
\newcommand{\bS}{\boldsymbol{\mathsf{S}}}

\newcommand{\ul}[1]{\underline{#1}}
\newcommand{\ulGamma}{\ul{\Gamma}}
\newcommand{\ulDelta}{\ul{\Delta}}
\newcommand{\ulgamma}{\ul{\gamma}}
\newcommand{\ulOmega}{\ul{\Omega}}
\newcommand{\uldelta}{\ul{\delta}}
\newcommand{\ulsigma}{\ul{\sigma}}
\newcommand{\ulepsilon}{\ul{\epsilon}}
\newcommand{\ult}{\ul{t}}
\newcommand{\ulu}{\ul{u}}
\newcommand{\ulA}{\ul{A}}
\newcommand{\ulB}{\ul{B}}
\newcommand{\tos}{\mathsf{tos}}

\newcommand{\coe}{\mathsf{coe}}
\newcommand{\coh}{\mathsf{coh}}
\newcommand{\llb}{\llbracket}
\newcommand{\rrb}{\rrbracket}


%% ------------------------------------------------------------



\begin{document}

%% Title information
\title{Large and Infinitary Quotient Inductive-Inductive Types} %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%% \titlenote{with title note}             %% \titlenote is optional;
%%                                         %% can be repeated if necessary;
%%                                         %% contents suppressed with 'anonymous'
%% \subtitle{Subtitle}                     %% \subtitle is optional
%% \subtitlenote{with subtitle note}       %% \subtitlenote is optional;
%%                                         %% can be repeated if necessary;
%%                                         %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

\author{Andr{\'a}s Kov{\'a}cs}
\orcid{0000-0002-6375-9781}
\affiliation{
  \department{Department of Programming Languages and Compilers}
  \institution{E{\"o}tv{\"o}s Lor{\'a}nd University}
  \city{Budapest}
  \country{Hungary}                   %% \country is recommended
}
\email{kovacsandras@inf.elte.hu}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Quotient inductive-inductive types (QIITs) are generalized inductive types which
allow sorts to be indexed over previously declared sorts, and allow usage of
equality constructors. QIITs are especially useful for algebraic descriptions of
type theories and constructive definitions of real, ordinal and surreal
numbers. We develop new metatheory for large QIITs, large elimination, recursive
equations and infinitary constructors. As in prior work, we describe QIITs using
a type theory where each context represents a QIIT signature. However, in our
case the theory of signatures can also describe its own signature, modulo
universe sizes. We bootstrap the model theory of signatures using
self-description and a Church-coded notion of signature, without using
complicated raw syntax or assuming an existing internal QIIT of signatures. We
give semantics to described QIITs by modeling each signature as a finitely
complete CwF (category with families) of algebras. Compared to the case of
finitary QIITs, we additionally need to show invariance under algebra
isomorphisms in the semantics. We do this by modeling signature types as
isofibrations. Finally, we show by a term model construction that every QIIT is
constructible from the syntax of the theory of signatures.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003790.10011740</concept_id>
<concept_desc>Theory of computation~Type theory</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{inductive types, infinitary inductive types, quotient inductive-inductive types, categories with families}


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\section{Introduction}

The aim of this work is to provide theoretical underpinning to a general notion
of inductive types, called quotient inductive-inductive types (QIITs). QIITs are
of interest because there are many commonly used mathematical structures, which
can be conveniently described as QIITs in type theory, but cannot be defined as
less general inductive types, or doing so incurs large encoding overhead.

Categories are a prime example for a structure which is described by a quotient
inductive-inductive signature. Signatures for QIITs allow having multiple sorts,
with later ones indexed over previous ones, and equations as well. We need both
features in order to write down the signature of categories.

The benefit of having a QIIT signature is getting a model theory ``for free'',
from the metatheory of QIITs. This model theory includes a category of algebras
which has an initial object and also some additional structure. For the
signature of categories, we get the empty category as the initial object, but it
is common to consider categories with more structure, which have more
interesting initial models.

Algebraic notions of models of type theories are examples for this. Here,
initial models represent syntax, and initiality corresponds to induction on
syntax. Several variants have been used, from contextual categories \cite{gat}
and comprehension categories \cite{jacobs1993comprehension} to categories with
families \cite{Dybjer96internaltype}. Additionally, real, surreal \cite{HoTTbook}
and ordinal numbers \cite{lumsdaineShulman} can be defined as \emph{infinitary}
QIITs, which are represented as possibly infinitely branching inductive trees.

%% The main motivation of the current paper is to generalize previously formalized
%% \cite{kaposi2019constructing} QIITs so that they accommodate more algebraic
%% formulations of type theories, and more aspects of their practical
%% metatheory. As a side effect of fulfilling this goal, infinitary QIITs such as
%% Cauchy real numbers \cite{TODO} are covered as well.

\subsection{Contributions}
The current paper extends the syntax and semantics of QIITs as previously described
in the literature \cite{kaposi2019constructing, gabe, dijkstra2017quotient}. We add the following features:
\begin{enumerate}
  \item
  \textbf{Large constructors, large elimination} and algebras at different
  universe levels. This fills in an important formal gap; large models are
  routinely used in the metatheory of type theories, but they have not been
  presented explicitly in previous QIIT literature.
  \item
  \textbf{Infinitary constructors}.
  Of special note here is that the theory of QIIT signatures is itself large and
  infinitary, thus it can ``eat itself'', i.e.\ include its own signature and
  provide its own metatheory. This was not possible previously in
  \cite{kaposi2019constructing}, where only finitary QIITs were described. In
  this paper we use self-representation to bootstrap the model theory of
  signatures, without having to assume any pre-existing internal syntax.
  \item
  \textbf{Recursive equations}, i.e. equations appearing as assumptions
  of constructors. These have occurred previously in syntaxes of cubical type
  theories, as boundary conditions\cite{TODO}.
\end{enumerate}

To provide semantics, we show that for each signature, there is a CwF (category
with families) of algebras, extended with $\Sigma$-types, extensional identity,
and constant families. This additional structure corresponds to a type-theoretic
flavor of finite limits, as it was shown in \cite{clairambault2014biequivalence}
that the category of such CwFs is biequivalent to the category of finitely
complete categories.

Compared to the case of finitary QIITs, the addition of infinitary constructors
and recursive equations requires a significant change in semantics: instead of
strict CwF morphisms, we need to consider weak ones, and instead of modeling
types as displayed CwFs, we need to model them as CwF isofibrations. The latter
amounts to showing that signature extension respects algebra isomorphisms.

We also show, by a term model construction, that all QIITs are reducible to the
syntax of signatures. This construction also essentially relies on invariance under
isomorphisms.

\subsection{Outline of the Paper}

In Section \ref{sec:metatheory}, we describe the metatheory used in the rest of
the paper. In Section \ref{sec:tos}, we introduce the theory of QIIT
signatures. In Section \ref{sec:semantics} we give categorical semantics to
signatures. In Section \ref{sec:tossig} we build model theory for the theory
of QIIT signatures. In Section \ref{sec:termmodels} we give a term model construction
of QIITs. We discuss related work and conclude in Sections \ref{sec:relatedwork}-\ref{sec:conclusion}.

\section{Metatheory}
\label{sec:metatheory}

The metatheory used in this paper is extensional type theory, extended with a
form of cumulativity and an external notion of universe polymorphism. We refer
to this theory as cETT. We review the used features and notations
in the following.

\subsection{Core Extensional Theory}

We have Russell-style predicative universes $\Set_i$ indexed by natural
numbers, dependent functions as $(x : A)\ra B$, and dependent pairs as $(x :
A)\times B$ with projections $\proj1$ and $\proj2$. We sometimes leave
parameters implicit in dependent function types, e.g.\ write $\id : A \ra A$
instead of $\id : (A : \Set_i)\ra A \ra A$. We also use subscripts as a field
projection notation for iterated pairs. For example, for $t : (A : \Set_i)
\times (B : \Set_i) \times (f : A \ra B)$, we use $B_t$ to denote the projection
of the second component. Sometimes we omit the subscript if it is clear from
context. When we write ``exists'' in this paper, we always mean chosen structure
given by a $\Sigma$-type.

Both for function types and $\Sigma$, the output universe level is given as the
maximum of the levels of the constituent types, e.g.\ $(x : A)\ra B : \Set_{\max(i,j)}$
when $A : \Set_i$ and $B : \Set_j$.

We write propositional equality as $t = u$, with $\refl_t$ for reflexivity. We
have equality reflection and uniqueness of identity proofs (UIP). The unit type
is $\top : \Set_0$, with inhabitant $\tt$.

\subsection{Cumulativity}
\label{sec:cumulativity}

We use cumulative universes and cumulative subtyping as described
in \cite{timany2018cumulative}. Concretely, we have a $\blank\leq\blank$ subtyping
relation on types, specified by the following rules:
\begin{mathpar}
  \inferrule*{i \leq j}
             {\Gamma \vdash \Set_i \leq \Set_j}

  \inferrule*{\Gamma,\,x : A \vdash B \leq B'}
             {\Gamma \vdash (x : A)\ra B \leq (x : A)\ra B'}

  \inferrule*{\Gamma\vdash A \leq A' \\ \Gamma,\,x : A \vdash B \leq B'}
             {\Gamma \vdash (x : A)\times B \leq (x : A') \times B'}

  \inferrule*{\\}
             {\Gamma \vdash A \leq A}

  \inferrule*{\Gamma \vdash A \leq B \\ \Gamma\vdash B \leq C}
             {\Gamma \vdash A \leq C}

  \inferrule*{\Gamma\vdash A \leq A' \\ \Gamma\vdash t : A}
             {\Gamma \vdash t : A'}
\end{mathpar}

Additionally, we have an internal type for $\blank\leq\blank$, analogously to
$\blank=\blank$ which is an internalization of definitional equality.
\begin{mathpar}
  \inferrule*{\Gamma \vdash A : \Set_i \\ \Gamma \vdash B : \Set_j}
             {\Gamma \vdash \Subtype\,A\,B : \Set_{\max(i, j)}}

  \inferrule*{\Gamma \vdash A \leq B}
             {\Gamma \vdash \subtype : \Subtype\,A\,B}

  \inferrule*{\Gamma \vdash t : \Subtype\,A\,B}
             {\Gamma \vdash A \leq B}
\end{mathpar}

We use cumulativity to reduce bureaucratic overhead when dealing with
constructions at different universe levels. The internal $\Subtype$ is used in
Section \ref{sec:termmodels} to prove cumulativity for general QIIT
algebras. For example, consider natural number algebras at level $i$, given as
the $\Sigma$-type $NatAlg_i :\equiv(Nat : \Set_i)\times Nat\times(Nat \ra
Nat)$. It follows from the subtyping rules that $i \leq j$ implies $NatAlg_{i}
\leq NatAlg_{j}$. However, cumulativity for arbitrary QIIT algebras does not
follow judgmentally; it can only be proven by induction on signatures, hence
the need for $\Subtype$.

Internal subtyping is not included in \cite{timany2018cumulative}, but it can be
justified by the set-theoretic model given there.

\subsection{Universe Polymorphism}
\label{sec:universe_polymorphism}

We need to talk about constructions at arbitrary universe levels. For the sake
of simplicity, we do not assume a notion of universe polymorphism in cETT,
instead we quantify over levels in an unspecified theory outside of cETT. Hence,
a universe polymorphic cETT term is understood as a $\mathbb{N}$-indexed family
of cETT terms. We reuse the notation of cETT functions for
universe polymorphism, e.g.\ as in the following function:
\[
\lambda\,i.\,\Set_i : (i : \mathbb{N})\ra \Set_{i+1}
\]

\section{QIIT Signatures}
\label{sec:tos}

Signatures are given as contexts in a certain type theory, the theory of
signatures. We shall abbreviate it as ToS. However, ToS turns out to be a large
infinitary QIIT itself, and we would like to define ToS and a notion of
signature without referring to QIITs, only using features present in cETT. As a
first step, we define a notion of model.

\begin{definition}[Notion of model for the theory of signatures]\label{def:tos}
For levels $i$ and $j$, $\ToS_{i,j} : \Set_{\max(i+1,\,j+1)}$ is a cETT type whose
elements are ToS models (or ToS-algebras). $\ToS_{i,j}$ is an iterated
$\Sigma$-type, containing all of the following components.

A \textbf{category with families} (CwF), where all four underlying sets (of
objects, morphisms, types and terms) are in $\Set_i$. Following notation in
\cite{kaposi2019constructing}, we denote these respectively as $\Con : \Set_i$,
$\Sub : \Con \ra \Con \ra \Set_i$, $\Ty : \Con \ra \Set_i$ and $\Tm : (\Gamma :
\Con) \ra \Ty\,\Gamma \ra \Set_i$. We use $\id$ and $\blank\circ\blank$ to
denote identity and composition for substitution. We denote the empty context as
$\emptycon : \Con$, and the unique substitution into the empty context as
$\epsilon : \Sub\,\Gamma\,\emptycon$. Context extension is $\blank\ext\blank :
(\Gamma : \Con)\ra \Ty\,\Gamma \ra \Con$. Substitution on types and terms is
written as $\blank[\blank]$. Projections are noted as $\p :
\Sub\,(\Gamma\,\ext\,A)\,\Gamma$ and $\q : \Tm\,(\Gamma\,\ext\,A)\,(A[\p])$, and
substitution extension is $\blank,\blank : (\sigma : \Sub\,\Gamma\,\Delta)\ra
\Tm\,\Gamma\,(A[\sigma])\ra \Sub\,\Gamma\,(\Delta\ext A)$.

A \textbf{universe} $\U : \Ty\,\Gamma$ with decoding $\El : (a :
\Tm\,\Gamma\,\U) \ra \Ty\,\Gamma$.

\textbf{Inductive function space} $\Pii : (a : \Tm\,\Gamma\,\U) \ra
\Ty\,(\Gamma\,\ext\,\El\,a) \ra \Ty\,\Gamma$, with application as $\appi :
\Tm\,\Gamma\,(\Pii\,a\,B)\ra \Tm\,(\Gamma\,\ext\,\El\,a)\,B$ and its
inverse $\lami$.

\textbf{External function space} $\Pie : (A : \Set_j)\ra(A \ra \Ty\,\Gamma)\ra
\Ty\,\Gamma$, with $\appe : \Tm\,\Gamma\,(\Pie\,A\,B)\ra((x : A)\ra
\Tm\,\Gamma\,(B\,x))$ and its inverse $\lame$.

\textbf{Infinitary function space} $\Piinf : (A : \Set_j)\ra(A \ra
\Tm\,\Gamma\,\U)\ra \Tm\,\Gamma\,\U$, with $\appinf :
\Tm\,\Gamma\,(\El\,(\Pie\,A\,b))\ra((x : A)\ra \Tm\,\Gamma\,(\El\,(b\,x)))$ and
its inverse $\laminf$.

\textbf{An identity type} $\Id : (a : \Tm\,\Gamma\,\U)\ra
\Tm\,\Gamma\,(\El\,a)\ra\Tm\,\Gamma\,(\El\,a)\ra \Tm\,\Gamma\,\U$, with $\Refl :
(t : \Tm\,\Gamma\,(\El\,a))\ra \Tm\,\Gamma\,(\El\,(\Id\,a\,t\,t))$, equality reflection and UIP.

\end{definition}
In the above listing, we omit equations for substitution and
$\beta\eta$-conversion, but these should be understood to be also part of
$\ToS_{i,j}$.

\emph{Notational conventions.} We name elements of $\Con$ as $\Gamma$, $\Delta$,
$\Theta$, elements of $\Sub\,\Gamma\,\Delta$ as $\sigma$, $\delta$, $\nu$,
elements of $\Ty\,\Gamma$ as $A$, $B$, $C$, and elements of $\Tm\,\Gamma\,A$ as
$t$, $u$, $v$. CwF components by default support de Bruijn indices, which are
not easily readable. We use instead a nameful notation for binders in context
extension, $\Pii$ and $\lami$, e.g.\ as $(\emptycon\,\ext (a : U) \ext (t :
\El\,a))$. We also define a type-theoretic flavor of $\appi$ for convenience:
\begin{alignat*}{3}
  & \blank\appitt\blank && :
      \Tm\,\Gamma\,(\Pii\,a\,B)\ra
      (u : \Tm\,\Gamma\,(\El\,a)) \ra \Tm\,\Gamma\,(B[\id, u])\\
  & t\appitt u && :\equiv (\appi\,t)[\id, u]
\end{alignat*}
We abbreviate non-dependent inductive $\Pii$ as $\blank\arri\blank$, and
likewise we use $\blank\arre\blank$ and $\blank\arrinf\blank$ for non-dependent
external and infinitary functions.

%% We use abbreviations for non-dependent function types:
%% \begin{alignat*}{3}
%%   & A\arri B && :\equiv \Pi\,A\,(B[\p])\\
%%   & A \arre\,B &&:\equiv \Pie\,A\,(\lambda\,\_.\,B) \\
%%   & A \arrinf\,B &&:\equiv \Piinf\,A\,(\lambda\,\_.\,B)
%% $A\arri B :\equiv \Pi\,A\,(B[\p])$, and $A \arre\,B :\equiv \Pie\,A\,(\lambda\,\_.\,B)$, and likewise
%% $A \arrinf\,B :\equiv \Piinf\,A\,(\lambda\,\_.\,B)$.

\begin{definition}[Notion of signature]\label{def:signature}
A QIIT signature at level $j$ is a context in an arbitrary $M : \ToS_{i,j}$
model. We define the type of such signatures as follows:
\[
  \Sig_j :\equiv (i : \mathbb{N})\ra(M : \ToS_{i,j})\ra \Con_M
\]

Here, $j$ refers to the level of external types appearing in the signature, in
the domains of $\Pie$ and $\Piinf$ functions, while the quantified $i$ level is
required to allow interpreting a signature in arbitrary-sized ToS models. Note
that $\Sig_j$ is universe-polymorphic, so it is a family of cETT types and it is
not in any cETT universe.

\begin{example}{
    Signature for natural numbers. Here, no external types appear, so the level
    can be chosen as $0$.}
\begin{alignat*}{3}
  & \NatSig : \Sig_0 \\
  & \NatSig :\equiv \lambda (i :\mathbb{N})(M : \ToS_{i,0}).\\
  & \hspace{1em}(\emptycon_M\,\ext_M\, (N : \U_M) \,\ext_M\,(zero : \El_M\,N)\\
  & \hspace{2.67em}\ext_M (suc : N\arri_M\El_M\,N))
\end{alignat*}
\end{example}

With this, we are able to specify QIITs, and we can also interpret each
signature in an arbitrary ToS model, by applying a signature to a model.
$\Sig_j$ can be viewed as a precursor to a Church-encoding for the theory of
signatures, but we only need contexts encoded in this way, and not other ToS
components. In functional programming, this is sometimes called ``finally
tagless'' \cite{carette2007finally}, and it is used for defining and interpreting
embedded languages.
\end{definition}

In the following examples, we leave the abstracted $M : \ToS_{i,j}$ implicit.

\begin{example}{Infinitary constructors}. The universe $\U$ is closed under
the $\Piinf$ function type, which allows such functions to appear in the domains
of $\Pii$ types. This allows, for example, a signature for trees branching with
arbitrary small types. This is a signature at level 1, since we have $\Set_0$ as
a $\Pie$ domain type.
\begin{alignat*}{3}
& \mathsf{TreeSig} :\equiv \\
& \hspace{1em}\emptycon \ext (Tree : \U)\\
& \hspace{1.35em}\ext (node : \Pie\,\Set_0\,(\lambda A.\,(A\,\arrinf\,Tree)\arri\El\,Tree))
\end{alignat*}
\end{example}

%% \begin{example}{Sort equations}. An interesting example is the term lifting
%% rule for cETT (omitting everything except term lifting):
%% \begin{alignat*}{3}
%%   & cETTSig :\equiv \\
%%   & ...\,\ext\,Tm{\Lift} : \Pii\,(\Gamma : Con)\,(\Pii\,(A : Ty{\appitt}\Gamma)((\IdU\,(Tm{\appitt}\Gamma{\appitt}A)\,(Tm{\appitt}\Gamma{\appitt}(\Lift_j{\appitt}A))))
%% \end{alignat*}
%% \end{example}

\begin{example}{Recursive equations}. Again, the universe is closed under $\Id$, which allows us to write equations
in $\Pii$ domains. A minimal (and trivial) example:
\begin{alignat*}{3}
  & \mathsf{RecEqSig} :\equiv\\
  & \hspace{0.5em}\emptycon\,\ext (A : \U) \ext (a : \El\,A)\ext (f : \Pii\,(x : A)\,(\Id\,A\,x\,a\arri\El\,A))
\end{alignat*}
More interesting (and complicated) examples for recursive equations are boundary
conditions in various cubical type theories \cite{cohen2016cubical, angiuli2016computational, angiuli2018cartesian}. Note that our $\Id$
allows iterated equations as well, but these are all trivial in the semantics,
where we assume UIP.
\end{example}


\emph{Remark.} Since signatures are parametrized by a single universe level, all
external types in constructors must be contained in the same $\Set_j$
universe. We opted for this setup for the sake of simplicity. Cumulativity helps
here: it allows us to pick a $j$ level which is large enough to accommodate all
external types in a signature.


\section{Semantics}
\label{sec:semantics}

\subsection{Overview}\label{sec:overview}

For each signature, we would like to have at least
\begin{enumerate}
  \item A category of algebras, with homomorphisms as morphisms.
  \item A notion of induction, which requires a notion of dependent algebras.
  \item A proof that for algebras, initiality is equivalent to supporting induction.
\end{enumerate}

Following \cite{kaposi2019constructing}, we do this by creating a model of ToS,
where contexts are categories supporting the above requirements and
substitutions are appropriate structure-preserving functors. Then, each
signature can applied to this model, yielding an interpretation of the signature
as a structured category of algebras.

Our semantics has a ``type-theoretic'' flavor, which is inspired by the cubical
set model of Martin-Löf type theory by Bezem et al. \cite{cubical}. The core idea
is to avoid strictness issues by starting from basic ingredients which are already
strict enough. Hence, instead of modeling types as certain slices and
substitution by pullback, we model types as displayed categories with extra
structure, which naturally support strict reindexing.

We make a similar choice in the interpretation of signatures themselves: we use
structured CwFs instead of lex categories. The reason here is that CwFs allow us
to compute induction principles in strictly the same way as one would write them
down in type theory, since we have $\Ty$ and $\Tm$ for a primitive notion of
dependent objects and morphisms. In contrast, dependent objects in lex
categories is a derived notion, and the induction principles we get are only up
to isomorphism. This issue is perhaps not relevant from a purely categorical
perspective, but we are concerned with eventually implementing QIITs in proof
assistants, so we prefer if our semantics computes strictly.

In the following, for given $i$ and $j$ levels, we define a model $\bM_{i,j} :
\ToS_{\max(i+1,j)+1, j}$ such that $\Con_{\bM_{i,j}}$ is a type of structured
categories (of algebras). The level $i$ marks the level of all internal sorts in
an algebra, and the level $j$ marks the level of all external sets in function
domains. Hence, every algebra has level $\max(i+1,j)$. The bump is only needed
for $i$, since algebras merely contain elements of $A : \Set_j$ types, while
inductive sets are themselves elements of $\Set_i$. For example, $NatAlg_i :
\Set_{\max(i+1,0)} : \Set_{\max(i+1, 0)+1}$.


We present the components of the model in order. In the following, we use
\textbf{bold} font to disambiguate components of $\bM_{i,j}$ from components of other
structures. For example, we use $\boldsymbol{\sigma : \Sub\,\Gamma\,\Delta}$ to
denote a substitution in $\bM_{i,j}$.

The model involves a large amount of technical detail; we omit a significant
part of this, and only present the most salient parts.

\subsection{Contexts}

We define $\bCon : \Set_{\max(i+1,j)+1}$ as $\flCwF_{\max(i+1,j)}$.
%% We define
%% $\flCwF$ as follows.

\begin{definition}[Finite limit CwFs]\label{def:flCwF}
For each level $i$ we define $\flCwF_i : \Set_{i+1}$ as an iterated $\Sigma$-type
with the following components:
\begin{enumerate}
  \item A CwF with underlying sets all in $\Set_i$. We reuse the component
    notations from Definition \ref{def:tos}.
  \item $\Sigma$-type $\Sg : (A : \Ty\,\Gamma)\ra \Ty\,(\Gamma \ext A)
    \ra \Ty\,\Gamma$, with term formers $\proj1$, $\proj2$ and $\blank,\blank$.
  \item Identity type $\Id : (A : \Ty\,\Gamma)\ra \Tm\,\Gamma\,A\ra
    \Tm\,\Gamma\,A\ra \Ty\,\Gamma$, with $\refl$, equality reflection and UIP.
  \item Constant families. This includes a type former $\Kfam : \Con \ra
    \Ty\,\Gamma$, where $\Gamma$ is implicitly quantified, together with $\lamK
    : \Sub\,\Gamma\,\Delta \ra \Tm\,\Gamma\,(\Kfam\,\Delta)$ and its inverse
    $\appK$. The idea is that $\Kfam\,\Delta$ is a representation of $\Delta$ as
    a type in any context. Clairambault and Dybjer called constant families
    ``democracy'' in \cite{clairambault2014biequivalence}.
\end{enumerate}
\end{definition}

\begin{definition} We abbreviate the additional structure on CwFs consisting of $\Sigma$, $\Id$ and
$\Kfam$ as \emph{fl-structure}.
\end{definition}

%% We abbreviate the additional structure on CwFs consisting of $\Sigma$, $\Id$ and
%% $\Kfam$ as fl-structure. We use $\Ty$ in an flCwF to represent ``dependent
%% objects'', and $\Tm$ for ``dependent morphisms''. We use these to define
%% induction.

\begin{definition}[Notion of induction in an flCwF]\label{def:induction}
Given $\bGamma : \flCwF_i$, we have the following predicate on contexts:
\begin{alignat*}{3}
  & \Inductive : \Con_{\bGamma} \ra \Set_i \\
  & \Inductive\,\Gamma :\equiv (A : \Ty_{\bGamma}\,\Gamma)\ra \Tm_{\bGamma}\,\Gamma\,A
\end{alignat*}
\end{definition}

In the categorical semantics for a concrete signature, this informally means
that an algebra supports induction if for any dependent algebra over it (which
is a bundle of induction motives and methods), there is a dependent morphism
into it (which is a bundle of eliminator functions and their $\beta$-rules).

\begin{theorem}[Equivalence of initiality and induction, c.f. \cite{kaposi2019constructing}]\label{thm:initialind}
An object $\Gamma : \Con_{\bGamma}$ supports induction if and only if it is
initial. Moreover, induction and initiality are both proof-irrelevant
predicates. \qed
\end{theorem}

The reason for the ``finite limit CwF'' naming is the following: Clairambault
and Dybjer showed that the 2-category of flCwFs is biequivalent to the
2-category of finitely complete categories
\cite{clairambault2014biequivalence}. In particular, in an flCwF the categorical
product of $\Gamma$ and $\Delta$ can be given as $\Gamma \ext \Kfam\, \Delta$,
and the equalizer of $\sigma$ and $\delta$ as $\Gamma\ext
\Id\,(\K\,\Delta)\,(\lamK\,\sigma)\,(\lamK\,\delta)$.

In order to talk about weak structure-preservation in the interpretation of substitutions, we need to specify isomorphisms for contexts and types.

\begin{definition} A \emph{context isomorphism} is an invertible morphism $\sigma : \Sub\,\Gamma\,\Delta$. We note the inverse as $\sigma^{-1}$. We also use the notation $\sigma : \Gamma \simeq \Delta$.
\end{definition}

\begin{definition}[Type categories, c.f.\ \cite{clairambault2014biequivalence}]\label{def:type_categories} For each $\Gamma : \Con$, there is a category
whose objects are types $A : \Ty\,\Gamma$, and morphisms from $A$ to $B$ are
terms $t : \Tm\,(\Gamma\,\ext\,A)\,B[\p]$. Identity morphisms are given by $\q :
\Tm\,(\Gamma\,\ext\,A)\,A[\p]$, and composition $t \circ u$ by $t[\p, u]$. The
assignment of type categories to contexts extends to a split indexed category. For
each $\sigma : \Sub\,\Gamma\,\Delta$, there is a functor from $\Ty\,\Delta$ to
$\Ty\,\Gamma$, which sends $A$ to $A[\sigma]$ and $t :
\Tm\,(\Gamma\,\ext\,A)\,B[\p]$ to $t[\sigma\circ \p, \q]$.
\end{definition}

\begin{definition} A \emph{type isomorphism}, notated $t : A \simeq B$ is an isomorphism in a type category. We note the inverse as $t^{-1}$.
\end{definition}

\subsection{Substitutions}
\label{sec:substitutions}

A \emph{weak flCwF morphism} $\boldsymbol{\sigma : \Sub\,\Gamma\,\Delta}$ is a functor between underlying categories, which additionally maps types to types and terms to terms, and satisfies the following:
  \begin{enumerate}
    \item $\bsigma\,(A[\sigma]) = (\bsigma\,A)\,[\bsigma\,\sigma]$
    \item $\bsigma\,(t[\sigma]) = (\bsigma\,t)\,[\bsigma\,\sigma]$
    \item The unique map $\epsilon : \Sub\,(\bsigma\,\emptycon)\,\emptycon$ has a retraction.
    \item Each $(\bsigma\,\p,\,\bsigma\,\q) : \Sub\,(\bsigma\,(\Gamma\,\ext\,A))\,(\bsigma\,\Gamma\,\ext\,\bsigma\,A)$ has an inverse.
  \end{enumerate}


In short, $\bsigma$ preserves substitution strictly and preserves
empty context and context extension up to isomorphism. We notate the evident
isomorphisms as $\bsigma_{\emptycon} :
\bsigma\,\emptycon \simeq \emptycon$ and $\bsigma_{\ext}
:
\bsigma\,(\Gamma\,\ext\,A)\,\simeq\,\bsigma\,\Gamma\,\ext\,\bsigma\,A$. Our notion of weak morphism is the same as in \cite{birkedal2018modal}, when restricted to CwFs.

Note that the definition we just gave lives in $\Set_{\max(i+1,j)}$, but by
cumulativity it is also in $\Set_{\max(i+1,j)+1}$, as required by our $\bM_{i,j}
: \ToS_{\max(i+1,j)+1, j}$ specification of the model being defined.

\begin{theorem}\label{thm:flpres} Every $\boldsymbol{\sigma : \Sub\,\Gamma\,\Delta}$ preserves fl-structure up to type isomorphism. That is, we have
\begin{alignat*}{3}
  & \bsigma_{\Sigma} : \bsigma\,(\Sigma\,A\,B) \simeq \Sigma\,(\bsigma\,A)\,((\bsigma\,B)[\bsigma_{\ext}^{-1}]) \\
  & \bsigma_{\K} : \bsigma\,(\K\,\Delta) \simeq \K\,(\bsigma\,\Delta) \\
  & \bsigma_{\Id} : \bsigma\,(\Id\,t\,u) \simeq \Id\,(\bsigma\,t)\,(\bsigma\,u)
\end{alignat*}
These are all natural in the following sense: for $\sigma :
\Sub_{\bGamma}\,\Gamma\,\Delta$, the functorial action of $\bsigma\,\sigma :
\Sub_{\bDelta}\,(\bsigma\,\Gamma)\,(\bsigma\,\Delta)$ on $\bsigma_{\Sigma}$ (in
the $\bsigma\,\Gamma$ context) is equal to $\bsigma_{\Sigma}$ (in
$\bsigma\,\Delta$), and similarly for $\bsigma_{\K}$ and $\bsigma_{\Id}$.

Moreover, $\bsigma$ preserves all term and substitution formers in the
fl-structure. For example, $\bsigma\,(\proj1\,t) = \proj1\,
(\bsigma_{\Sigma}[\id, \bsigma\,t])$.
\end{theorem}
\begin{proof}
For $\bsigma_{\Sigma}$, we construct the following context isomorphism:
\begin{alignat*}{3}
& (\bsigma\,\Gamma\,\ext\,\bsigma\,(\Sigma\,A\,B)) \simeq
  (\bsigma\,\Gamma\,\ext\,\bsigma\,A\,\ext\,(\Sigma\,B)[\bsigma_{\ext}^{-1}]) \\
& \simeq (\bsigma\,\Gamma\,\ext\,\Sigma\,(\bsigma\,A)\,((\Sigma\,B)[\bsigma_{\ext}^{-1}]))
\end{alignat*}
This isomorphism is the identity on $\bsigma\,\Gamma$, hence we can extract the
desired $\bsigma_{\Sigma} : \bsigma\,\Sigma\,A\,B) \simeq
\Sigma\,(\bsigma\,A)\,((\bsigma\,B)[\bsigma_{\ext}^{-1}])$ from it.

For $\bsigma_{\K}$, note the following:
\begin{alignat*}{3}
  & (\emptycon\,\ext\,\bsigma\,(\K\,\Delta)) \simeq
    (\bsigma\,\emptycon\,\ext\,\bsigma\,(\K\,\Delta)) \simeq
    \bsigma\,(\emptycon\,\ext\,\K\,\Delta)\\
  & \simeq \bsigma\,\Delta \simeq (\emptycon\,\ext\,K\,(\bsigma\,\Delta))
\end{alignat*}
This yields a type isomorphism $\bsigma\,(\K\,\Delta)) \simeq
\K\,(\bsigma\,\Delta)$ in the empty context, and we use the functorial action of
$\epsilon : \Sub\,\Gamma\,\emptycon$ to weaken it to any $\Gamma$ context.

For $\bsigma_{\Id}$, both component morphisms can be constructed by $\refl$ and
equality reflection, and the morphisms are inverses by UIP. We omit here the
verification of naturality and that $\bsigma$ preserves term and substitution
formers in the fl-structure.
\end{proof}

\subsection{Identity and Composition}
\label{sec:idcomp}

$\bid : \bSub\,\bGamma\,\bGamma$ is defined in the obvious way, with identities for
underlying functions and for preservation morphisms.

For $\boldsymbol{\sigma \circ \delta}$, the underlying functions are given by
function composition, and the preservation morphisms are given as follows:
\begin{alignat*}{3}
  & (\boldsymbol{\sigma \circ \delta})_{\emptycon}^{-1} :\equiv
    \bsigma\,\bdelta_{\emptycon}^{-1} \circ \bdelta_{\emptycon}^{-1} \\
  & (\boldsymbol{\sigma \circ \delta})_{\ext}^{-1} :\equiv
    \bsigma\,\bdelta_{\ext}^{-1} \circ \bdelta_{\ext}^{-1}
\end{alignat*}

It is easy to verify the left and right identity laws and associativity for $\boldsymbol{\blank\circ\blank}$.

\begin{lemma}\label{lem:idcomppres} The derived preservation isomorphisms for the fl-structure can be decomposed analogously; all derived isomorphisms in $\bid$ are identities, and we have
\begin{alignat*}{3}
  & (\boldsymbol{\sigma \circ \delta})_{\Sigma} =
  \bsigma\,\bdelta_{\Sigma} \circ \bdelta_{\Sigma}\\
  & (\boldsymbol{\sigma \circ \delta})_{\K} =
  \bsigma\,\bdelta_{\K} \circ \bdelta_{\K}\\
  & (\boldsymbol{\sigma \circ \delta})_{\Id} =
  \bsigma\,\bdelta_{\Id} \circ \bdelta_{\Id}
\end{alignat*}
On the right sides, $\blank\circ\blank$ refers to composition of type morphisms.
\end{lemma}
\begin{proof} In the case of $\Id$, the equations hold immediately by UIP. For $\Sigma$ and $\K$, we prove by flCwF computation and straightforward unfolding of definitions.
\end{proof}

\subsection{Empty Context}
The empty context $\boldsymbol{\emptycon : \Con}$ is the terminal flCwF, which
has all underlying sets defined as $\top$ (or constantly $\top$), with an
evident unique $\boldsymbol{\epsilon : \Sub\,\Gamma\,\emptycon}$. Since
$\bepsilon$ is a strict flCwF morphism, $\bepsilon_{\emptycon}^{-1}$ and
$\bepsilon_{\ext}^{-1}$ are both identity morphisms.

\subsection{Types}

We define $\boldsymbol{\Ty\,\Gamma} : \Set_{\max(i+1, j)+1}$ as the type of
split flCwF-isofibrations over $\bGamma$, at level $\max(i+1, j)$. We extend
Ahrens' and Lumsdaine's displayed categories and their definition of
isofibrations \cite{displayedcats}.  We first define displayed flCwFs, then
specify iso-cleaving as additional structure on top of that.

\begin{definition}[Displayed flCwF] The type of displayed flCwFs at level $i$ is given as the logical predicate interpretation (see e.g.\ \cite{bernardy12parametricity} or \cite{hiit}) of $\flCwF_i$. For each flCwF component in $\bGamma$, there is a component in a displayed flCwF which ``lies over'' it.

\emph{Notation.} In situations where we need to refer to both ``base'' and
displayed things, we give \ul{underlined} names to contexts, substitutions,
types and terms in a base flCwF. For example, we may have $\ulGamma :
\Con_{\bGamma}$ living in $\boldsymbol{\Gamma : \Con}$, and $\Gamma :
\Con_{\bA}\,\ulGamma$ living in a displayed flCwF over $\bGamma$. We only use
underlining on cETT variable names, and overload flCwF component names for
displayed counterparts. For example, a $\Con$ component is named the same in
a base flCwF and a displayed one.

Concretely, a displayed flCwF $\bA$ over $\bGamma$ has the following underlying sets, which we call displayed contexts, substitutions, types and terms respectively.
\begin{alignat*}{3}
  & \Con_{\bA} && : \Con_{\bGamma}\ra \Set_i\\
  & \Sub_{\bA} && : \Con_{\bA}\,\ulGamma \ra \Con_{\bA}\,\ulDelta \ra \Sub_{\bGamma}\,\ulGamma\,\ulDelta \ra \Set_i \\
  & \Ty_{\bA}  && : \Con_{\bA}\,\ulGamma \ra \Ty_{\bGamma}\,\ulGamma \ra \Set_i\\
  & \Tm_{\bA}  && : (\Gamma : \Con_{\bA}\,\ulGamma)\ra \Ty_{\bA}\,\Gamma\,\ulA \ra \Tm_{\bGamma}\,\ulGamma\,\ulA \ra \Set_i
\end{alignat*}

Above, we implicitly quantify over $\ulGamma$, $\ulDelta$ and $\ulA$ base
parameters. We also have the following components for empty context, context
extension and substitution. We omit listing other components here.
\begin{alignat*}{3}
  & \emptycon_{\bA} && : \Con_{\bA}\,\emptycon_{\bGamma}\\
  & \ext_{\bA}      && : (\Gamma : \Con_{\bA}\,\ulGamma)\ra \Ty_{\bA}\,\Gamma\,\ulA \ra
                     \Con_{\bA}\,\Gamma\,(\ulGamma \ext_{\bGamma} \ulA)\\
  & \blank[\blank]_{\bA} && : \Ty_{\bA}\,\Delta\,\ulA \ra \Sub_{\bA}\,\Gamma\,\Delta\,\ulsigma
                     \ra \Ty_{\bA}\,\Gamma\, (\ulA[\ulsigma]_{\bGamma})\\
  & \blank[\blank]_{\bA} && : \Tm_{\bA}\,\Delta\,A\,\ult \ra (\sigma : \Sub_{\bA}\,\Gamma\,\Delta\,\ulsigma)\\
  & && \hspace{0.5em}\ra \Tm_{\bA}\,\Gamma\, (A[\sigma]_{\bA})\,(\ult[\ulsigma]_{\bGamma})
\end{alignat*}
\end{definition}

In the following we will often omit $_{\bGamma}$ and $_{\bA}$ subscripts on
components; for example, in the type $\Con_{\bA}\,\emptycon$, the $\emptycon$ is clearly
a base component in $\bGamma$.

We also need displayed counterparts to the previously defined derived notions on flCwFs;
these are again given as logical predicate interpretations of the non-displayed definitions.

\begin{definition}[Displayed type categories] For each $\Gamma : \Con_{\bA}\,\ulGamma$, there
is a displayed category over the type category $\Ty_{\bGamma}\,\ulGamma$, whose objects
over $\ulA : \Ty_{\bGamma}\,\ulGamma$ are elements of $\Ty_{\bA}\,\Gamma\,\ulA$, and displayed morphisms over $\ult : \Tm_{\bGamma}\,(\ulGamma \ext \ulA)\,(\ulB[\p])$ are elements of $\Tm_{\bA}\,(\Gamma \ext A)\,(B[\p])\,\ult$. The identity morphism is given by $\q_{\bA}$, and the composition of $t$ and $u$ is $t[\p_{\bA},u]$. Analogously to Definition \ref{def:type_categories}, this extends to a displayed split indexed category.
\end{definition}

\begin{definition}[Displayed isomorphisms] A \emph{displayed context isomorphism} over $\ulsigma : \ulGamma \simeq \ulDelta$, notated $\sigma : \Gamma \simeq_{\ulsigma} \Delta$, is an invertible displayed morphism $\sigma : \Sub_{\bA}\,\Gamma\,\Delta\,\ulsigma$, with inverse $\sigma^{-1} : \Sub_{\bA}\,\Delta\,\Gamma\,\ulsigma^{-1}$. A \emph{displayed type isomorphism} over $\ult : \ulA \simeq \ulB$, notated $t : A \simeq_{\ult} B$, is an isomorphism in a displayed type category.
\end{definition}

\begin{definition} A \emph{vertical morphism} lies over an identity morphism. We use this definition for context morphisms (substitutions) and type morphisms as well.
\end{definition}

In contrast to \cite{kaposi2019constructing}, it is not sufficient to model
types with displayed flCwFs. In ibid.\ substitutions are modeled as strict
morphisms, which we cannot do because our infinitary function types and identity
types cannot be interpreted strictly, as we will see in Section
\ref{sec:infinitaryfunction}. Strict preservation is expressed with metatheoretic equality, which
is respected by all cETT constructions, but isomorphisms are not necessarily
respected. Hence, we need to add additional structure to displayed flCwFs which
expresses preservation of base isomorphisms.

\begin{definition}[Context iso-cleaving] This lifts a base context isomorphism to a displayed one. It consists of
\begin{alignat*}{3}
  & \coe &&: \ulGamma \simeq \ulDelta \ra \Con_{\bA}\,\ulGamma \ra \Con_{\bA}\,\ulDelta\\
  & \coh &&: (\ulsigma : \ulGamma \simeq \ulDelta)(\Gamma : \Con_{\bA}\,\ulGamma)
           \ra \Gamma \simeq_{\ulsigma} \coe\,\ulsigma\,\Gamma\\
  & \coe^{\id} && : \coe\,\id\,\Gamma = \Gamma\\
  & \coe^{\circ} && : \coe\,(\ulsigma\circ\uldelta)\,\Gamma = \coe\,\ulsigma\,(\coe\,\uldelta\,\Gamma)\\
  & \coh^{\id} && : \coh\,\id\,\Gamma = \id\\
  & \coh^{\circ} && : \coh\,(\ulsigma\circ\uldelta)\,\Gamma = \coh\,\ulsigma\,(\coe\,\uldelta\,\Gamma)
          \circ \coh\,\uldelta\,\Gamma
\end{alignat*}
Here, $\coe$ and $\coh$ abbreviate ``coercion'' and ``coherence'' respectively.
\end{definition}

\begin{definition}[Type iso-cleaving] This consists of
\begin{alignat*}{3}
  & \coe &&: \ulA \simeq \ulB \ra \Ty_{\bA}\,\Gamma\,\ulA \ra \Ty_{\bA}\,\Gamma\,\ulB\\
  & \coh &&: (\ult : \ulA \simeq \ulB)(A : \Ty_{\bA}\,\Gamma\,\ulA)
           \ra A \simeq_{\ult} \coe\,\ult\,A\\
  & \coe^{\id} && : \coe\,\id\,A = A\\
  & \coe^{\circ} && : \coe\,\ult\,(\coe\,\uldelta\,A) = \coe\,(\ult\circ\uldelta)\,A\\
  & \coh^{\id} &&: \coh\,\id\,A = \id\\
  & \coh^{\circ} &&: \coh\,(\ult\circ\uldelta)\,A = \coh\,\ult\,(\coe\,\uldelta\,A)
          \circ \coh\,\uldelta\,A
\end{alignat*}
Additionally, for $\sigma : \Sub_{\bA}\,\Gamma\,\Delta\,\ulsigma$, we have
\begin{alignat*}{3}
  & \coe[] &&: \coe\,(\ult[\ulsigma])\,(A[\sigma]) = (\coe\,\ult\,A)[\sigma]\\
  & \coh[] &&: \coh\,(\ult[\ulsigma\circ \p,\q])\,(A[\sigma]) = (\coh\,\ult\,A)[\sigma]
\end{alignat*}

\end{definition}

\begin{definition} A \emph{split flCwF isofibration} is a displayed flCwF equipped with iso-cleaving for contexts and types.
\end{definition}

\emph{Remark.} It is not possible to model types as fibrations or opfibrations,
because we have no restriction on the variance of ToS types. For example, the
type which extends a pointed set to a natural number signature, is neither a
fibration nor an opfibration.

\subsection{Type Substitution}
We aim to define $\boldsymbol{\blank[\blank] : \Ty\,\Delta \ra
  \Sub\,\Gamma\,\Delta \ra \Ty\,\Gamma}$, such that $\boldsymbol{A[\id]} = \bA$
and $\boldsymbol{A[\sigma\circ\delta]} = \boldsymbol{A[\sigma][\delta]}$. The
underlying sets are given by simple composition:
\begin{alignat*}{3}
  & \Con_{\boldsymbol{A[\sigma]}}\,\ulGamma && :\equiv \Con_{\bA}\,(\bsigma\,\ulGamma)\\
  & \Sub_{\boldsymbol{A[\sigma]}}\,\Gamma\,\Delta\,\ulsigma && :\equiv
    \Sub_{\bA}\,\Gamma\,\Delta\,(\bsigma\,\ulsigma)\\
  & \Ty_{\boldsymbol{A[\sigma]}}\,\Gamma\,\ulA && :\equiv
      \Ty_{\bA}\,\Gamma\,(\bsigma\,\ulA)\\
  & \Tm_{\boldsymbol{A[\sigma]}}\,\Gamma\,A\,\ult && :\equiv
      \Tm_{\bA}\,\Gamma\,A\,(\bsigma\,\ult)
\end{alignat*}

Moreover, $\id_{\boldsymbol{A[\sigma]}} :\equiv \id_{\bA}$,
$\sigma\circ_{\boldsymbol{A[\sigma]}}\delta :\equiv \sigma\circ_{\bA}\delta$,
and likewise substitution components are given by corresponding substitution
components in $\bA$.

Context and type formers are given by coercing $\bA$
structures along $\bsigma$ preservation isomorphisms. For example:
\begin{alignat*}{3}
  &\emptycon_{\boldsymbol{A[\sigma]}} && :\equiv
    \coe\,\bsigma_{\emptycon}^{-1}\,\emptycon_{\bA}\\
  &\Gamma\ext_{\boldsymbol{A[\sigma]}}A && :\equiv
    \coe\,\bsigma_{\ext}^{-1}\,(\Gamma\ext_{\bA} A)\\
  &\Id_{\boldsymbol{A[\sigma]}}\,t\,u && :\equiv
    \coe\,\bsigma_{\Id}^{-1}\,(\Id_{\bA}\,t\,u)
\end{alignat*}

Term and substitution formers are given by composing $\coh$-lifted
isomorphisms with term and substitution formers from $\bA$. For example:
\begin{alignat*}{3}
  & \epsilon_{\boldsymbol{A[\sigma]}} && :\equiv
    \coh\,\bsigma_{\emptycon}^{-1}\,\emptycon_{\bA} \circ \epsilon_{\bA}\\
  & \p_{\boldsymbol{A[\sigma]}} && :\equiv
    \p_{\bA} \circ (\coh\,\bsigma_{\ext}^{-1}\,(\Gamma\ext A))^{-1}\\
  & \appK_{\boldsymbol{A[\sigma]}}\,t && :\equiv
    \appK_{\bA}\,((\coh\,\bsigma_{\K}\,(\K\,\Delta))^{-1}\circ t)
\end{alignat*}
Equations for term and type substitution follow from naturality of preservation
isomorphisms in $\bsigma$, $\coe[]$, $\coh[]$ and substitution equations in
$\bA$.

Iso-cleaving is given iso-cleaving in $\bA$ and the action of $\bsigma$ on
isomorphisms, e.g.\ we have $\coe_{\boldsymbol{A[\sigma]}}\,\ulsigma\,\Gamma
:\equiv \coe_{\bA}\,(\bsigma\,\ulsigma)\,\Gamma$.

Functoriality of type substitution, i.e.\ $\boldsymbol{A[\id]} = \bA$ and
$\boldsymbol{A[\sigma\circ\delta]} = \boldsymbol{A[\sigma][\delta]}$, follows
from Lemma \ref{lem:idcomppres} and split cleaving given by $\coe^{\id}$,
$\coe^{\circ}$, $\coh^{\id}$ and $\coh^{\circ}$ laws in $\bA$.

\subsection{Terms}

$\boldsymbol{\Tm\,\Gamma\,A} : \Set_{\max(i+1, j)+1}$ is defined as the type of
\emph{weak flCwF sections} of $\bA$. The underlying functions of $\bt :
\bTm\,\bGamma\,\bA$ are as follows:
\begin{alignat*}{3}
  & \bt : (\ulGamma : \Con_{\bGamma}) \ra \Con_{\bA}\,\ulGamma\\
  & \bt : (\ulsigma : \Sub_{\bGamma}\,\ulGamma\,\ulDelta)
         \ra \Sub_{\bA}\,(\bt\,\ulGamma)\,(\bt\,\ulDelta)\,\ulsigma\\
  & \bt : (\ulA : \Ty_{\bGamma}) \ra \Ty_{\bA}\,(\bt\,\ulGamma)\,\ulA\\
  & \bt : (\ult : \Tm_{\bGamma}\,\ulGamma\,\ulA) \ra
          \Tm_{\bA}\,(\bt\,\ulGamma)\,(\bt\,\ulA)\,\ult
\end{alignat*}
Such that
\begin{enumerate}
  \item $\bt\,(\ulA[\ulsigma]) = (\bt\,\ulA)\,[\bt\,\ulsigma]$
  \item $\bt\,(\ult[\ulsigma]) = (\bt\,\ult)\,[\bt\,\ulsigma]$
  \item The unique map $\epsilon_{\bA} : \Sub\,(\bt\,\emptycon)\,\emptycon\,\id$ has a vertical retraction.
  \item Each $(\bt\,\p,\,\bt\,\q) : \Sub\,(\bt\,(\ulGamma\,\ext\,\ulA))\,(\bt\,\ulGamma\,\ext\,\bt\,\ulA)\,\id$ has a vertical inverse.
\end{enumerate}

Similarly to Section \ref{sec:substitutions}, we denote the evident preservation
isomorphisms as $\bt_{\emptycon} : \bt\,\emptycon \simeq_{\id} \emptycon$ and
$\bt_{\ext} : \bt\,(\ulGamma\ext \ulA) \simeq_{\id} \bt\,\ulGamma \ext
\bt\,\ulA$. In short, weak section is a dependently typed analogue of weak
morphism, with dependent underlying functions and displayed preservation
isomorphisms. We also have the derived fl-preservation isomorphisms.

\begin{theorem} A weak section $\boldsymbol{t : \Tm\,\Gamma\,A}$ preserves fl-structure up to vertical type isomorphisms, that is, the following are derivable:
\begin{alignat*}{3}
  & \bt_{\Sigma} : \bt\,(\Sigma\,\ulA\,\ulB) \simeq_{\id} \Sigma\,(\bt\,\ulA)\,((\bt\,\ulB)[\bt_{\ext}^{-1}]) \\
  & \bt_{\K} : \bt\,(\K\,\ulDelta) \simeq_{\id} \K\,(\bt\,\ulDelta) \\
  & \bt_{\Id} : \bt\,(\Id\,\ult\,\ulu) \simeq_{\id} \Id\,(\bt\,\ult)\,(\bt\,\ulu)
\end{alignat*}
Also, the above isomorphisms are natural in the sense of Theorem
\ref{thm:flpres}, and $\bt$ preserves type and substitution formers in the
fl-structure.
\end{theorem}
\begin{proof} The construction of isomorphisms is the same as in Theorem \ref{thm:flpres}. Indeed, every construction there has a displayed counterpart which we can use here.
\end{proof}

We note though that the move from Theorem \ref{thm:flpres} to here is not simply a
logical predicate translation, because we are only lifting the codomain of a
weak morphism to a displayed version, and we leave the domain non-displayed. We
leave to future work the investigation of such asymmetrical (or
``modal'') logical predicate translations.

\subsection{Term Substitution}

$\boldsymbol{\blank[\blank] : \Tm\,\Delta\,A \ra (\sigma : \Sub\,\Gamma\,\Delta)
  \ra \Tm\,\Gamma\,(A[\sigma])}$ is given similarly to
$\boldsymbol{\blank\circ\blank}$ in Section \ref{sec:idcomp}. Underlying functions
are given by function composition, and preservation morphisms are also similar:
\begin{alignat*}{3}
  & (\boldsymbol{t[\sigma]})_{\emptycon}^{-1} :\equiv
    \bt\,\bsigma_{\emptycon}^{-1} \circ \bt_{\emptycon}^{-1} \\
  & (\boldsymbol{t[\sigma]})_{\ext}^{-1} :\equiv
    \bt\,\bsigma_{\ext}^{-1} \circ \bt_{\ext}^{-1}
\end{alignat*}

We also have the same decomposition of derived isomorphisms as in Lemma
\ref{lem:idcomppres}. We do not have to show functoriality of term substitution
here, since that is derivable in any CwF \cite{TODO}.

\subsection{Context Extension and Comprehension}

$\boldsymbol{\Gamma \ext A : \Con}$ is defined as the \emph{total flCwF} of
$\bA$. This is given by bundling together all displayed flCwF components in
$\bA$ with corresponding base components in $\bGamma$, using the metatheoretic
$\Sigma$-type. It is a straightforward extension of total categories in
\cite{displayedcats}.

$\boldsymbol{\p : \Sub\,(\Gamma\ext A)\,\Gamma}$ is a strict morphism given by
taking a first projection for each component. $\boldsymbol{\q : \Tm\,(\Gamma\ext
  A)\,(A[\p])}$ is likewise a strict flCwF section given by second projections. Substitution extension $\boldsymbol{\sigma,\,t}$ is given by pointwise combining $\bsigma$ and $\bt$ with metatheoretic $\Sigma$ pairing, e.g.\ $\Con_{\boldsymbol{(\sigma,t)}}\,\ulGamma :\equiv (\bsigma\,\ulGamma,\,\bt\,\ulGamma)$.

\subsection{Universe}

\begin{definition} For a level $i$, we write $\bSet_i$ for the flCwF of sets where $\Con_{\bSet_i} :\equiv \Set_i$ and $\Sub_{\bSet_i}\,\Gamma\,\Delta :\equiv \Gamma \ra \Delta$.
\end{definition}

We define $\boldsymbol{\U : \Ty\,\Gamma}$ as the isofibration which is
constantly $\bSet_i$. A constant isofibration does not actually depend on the
base flCwF, and has trivial iso-cleaving where $\coe$-s are identity
functions. Hence, we have $\Con_{\bU}\,\ulGamma :\equiv \Set_i$ and
$\Sub_{\bU}\,\Gamma\,\Delta\,\ulsigma :\equiv \Gamma \ra \Delta$.

\emph{Remark.} The type $\bTm\,\bGamma\,\bU$ is strictly equal to
$\bSub\,\bGamma\,\bSet_i$, so it is helpful to think about semantic elements of
the universe as weak morphisms from $\bGamma$ to $\bSet_i$.

\subsection{Elements of the Universe}

We define $\boldsymbol{\El : \Tm\,\Gamma\,\U \ra \Ty\,\Gamma}$ as discrete
isofibration formation. For $\boldsymbol{a : \Tm\,\Gamma\,\U}$, the underlying
sets of $\bEl\,\ba$ are the following:
\begin{alignat*}{3}
  & \Con_{\bEl\,\ba}\,\ulGamma && :\equiv \ba\,\ulGamma\\
  & \Sub_{\bEl\,\ba}\,\Gamma\,\Delta\,\ulsigma && :\equiv \ba\,\ulsigma\,\Gamma = \Delta\\
  & \Ty_{\bEl\,\ba}\,\Gamma\,\ulA && :\equiv \ba\,\ulA\,\Gamma\\
  & \Tm_{\bEl\,\ba}\,\Gamma\,A\,\ult && :\equiv \ba\,\ult\,\Gamma = A
\end{alignat*}
Hence, in $\bEl\,\ba$, $\Sub$ and $\Tm$ are propositional. We use the
isomorphisms $\ba_{\emptycon} : \ba\,\emptycon \simeq \top$ and $\ba_{\ext} :
\ba\,(\ulGamma\ext\ulA) \simeq (\Gamma :
\ba\,\ulGamma)\times(\ba\,\ulA\,\Gamma)$ to define empty context and context
extension:
\begin{alignat*}{3}
  & \emptycon_{\bEl\,\ba} && :\equiv \ba_{\emptycon}^{-1}\,\tt\\
  & (\Gamma\ext_{\bEl\,\ba} A) && :\equiv \ba_{\ext}^{-1}\,(\Gamma,\,A)
\end{alignat*}
We likewise use preservation isomorphisms to define $\K$, $\Id$ and $\Sigma$.
Context coercion is $\coe\,\ulsigma\,\Gamma :\equiv \ba\,\ulsigma\,\Gamma$. Type coercion, for $A : \ba\,\ulA\,\Gamma$ is given as $\coe\,\ult\,A :\equiv \ba\,\ult\,(\ba_{\ext}^{-1}\,(\Gamma,\,A))$.

\subsection{Inductive Function Space}

For $\boldsymbol{a : \Tm\,\Gamma\,\U}$ and $\boldsymbol{B :
  \Ty\,(\Gamma\ext\El\,a)}$, we aim to define $\boldsymbol{\Pi\,a\,B}
\boldsymbol{:} \bTy\,\bGamma$. We define this as a dependent product of
isofibrations, indexed by a discrete domain. The discreteness is essential: with
a general $\bA \boldsymbol{:} \bTy\,\bGamma$ domain, $\bPii$ would not be
definable because of variance issues. Indeed, the category of categories is not
locally cartesian closed and does not support a general $\Pi$ type
\cite{johnstone2002sketches}.

Contexts are products of $\bB$-contexts, and types are products of $\bB$-types,
indexed respectively by contexts and types of $\bEl\,\ba$.
\begin{alignat*}{3}
  & \Con_{(\bPii\,\ba\,\bB)}\,\ulGamma &&:\equiv (\gamma : \ba\,\ulGamma)\ra \Con_{\bB}\,(\ulGamma, \gamma)\\
  & \Ty_{(\bPii\,\ba\,\bB)}\,\Gamma\,\ulA &&:\equiv (\gamma : \ba\,\ulGamma)(a : \ba\,\ulA\,\gamma)\ra \Ty_{\bB}\,(\Gamma\,\gamma)\,(\ulA, a)
\end{alignat*}
Note that since $\bB$ is over the total $\boldsymbol{(\Gamma\ext\El\,a)}$,
$\Con_{\bB}$ has a $\Sigma$-typed argument, and likewise the last argument
of every $\bB$ component.  We could define substitutions similarly, as
products of substitutions:
\begin{alignat*}{3}
  & \Sub_{(\bPii\,\ba\,\bB)}\,\Gamma\,\Delta\,\ulsigma :\equiv
  (\gamma : \ba\,\ulGamma)(\delta : \ba\,\ulDelta)
  (\sigma : \Sub_{(\bEl\,\ba)}\,\gamma\,\delta\,\ulsigma)\\
  &\hspace{6.5em}\ra \Sub_{\bB}\,(\Gamma\,\gamma)\,(\Delta\,\delta)\,(\ulsigma, \sigma)
\end{alignat*}
This would work, but we know that $\Sub_{(\bEl\,\ba)}\,\gamma\,\delta\,\ulsigma$ is defined
as $\ba\,\ulsigma\,\gamma = \delta$, so we can eliminate $\sigma$ by singleton contraction,
and use the following equivalent definition:
\begin{alignat*}{3}
  & \Sub_{(\bPii\,\ba\,\bB)}\,\Gamma\,\Delta\,\ulsigma :\equiv
  (\gamma : \ba\,\ulGamma)\ra\Sub_{\bB}\,(\Gamma\,\gamma)\,(\Delta\,(\ba\,\ulsigma\,\gamma)\,(\ulsigma, \refl)
\end{alignat*}
The benefit of the contracted definition is that it computes preservation laws
in algebra homomorphisms strictly as expected, while the non-contracted
definition computes homomorphisms as functional logical relations.

Terms are also given as a singleton-contracted version of products of terms. In
$\bPii\,\ba\,\bB$, all other structure is given pointwise by $\bB$-structure.

Iso-cleaving is given by transporting indices backwards in $\bEl\,\ba$ and outputs forwards
in $\bB$:
\begin{alignat*}{3}
  & \coe\,\ulsigma\,\Gamma &&:\equiv
    \lambda\,\gamma.\,\coe_{\bB}\,(\ulsigma,\refl)\,(\Gamma\,(\ba\,(\ulsigma^{-1})\,\gamma))\\
  & \coe\,\ult\,A &&:\equiv
    \lambda\,\gamma\,a.\,\coe_{\bB}\,(\ult,\refl)\,(A\,(\ba\,(\ult^{-1})\,(\ba_{\ext}^{-1}(\gamma,a))))
\end{alignat*}
Likewise, $\coh$-s are given by backwards-forwards $\coh$-s.

$\boldsymbol{\appi : \Tm\,\Gamma\,(\Pii\,a\,B)\ra
  \Tm\,(\Gamma\,\ext\,\El\,a)\,B}$ can be defined as currying of the underlying
functions, and $\boldsymbol{\lami}$ as uncurrying.


\subsection{External Function Space}

For $A : \Set_j$ and $\bB : A \ra \bTy\,\bGamma$, we define $\bPie\,A\,\bB
\boldsymbol{:} \bTy\,\bGamma$ as the $A$-indexed direct product of $\bB$. Since
the indexing is given by a metatheoretic function, every component is given in the
evident pointwise way.

\subsection{Infinitary Function Space}
\label{sec:infinitaryfunction}

For $A : \Set_j$ and $\bb : A \ra \bTm\,\bGamma\,\bU$, we aim to define
$\bPiinf\,A\,\bb \boldsymbol{:} \bTm\,\bGamma\,\bU$. The underlying functions
are:
\begin{alignat*}{3}
  & (\bPiinf\,A\,\bb)\,\ulGamma    &&:\equiv (a : A)\ra \bb\,a\,\ulGamma\\
  & (\bPiinf\,A\,\bb)\,\ulsigma    &&:\equiv \lambda\,a.\, \bb\,a\,\ulsigma\\
  & (\bPiinf\,A\,\bb)\,\ulA\       &&:\equiv \lambda\,\Gamma.\,(a : A)\ra \bb\,a\,\ulA\,(\Gamma\, a)\\
  & (\bPiinf\,A\,\bb)\,\ult        &&:\equiv \lambda\,a.\, \bb\,a\,\ult
\end{alignat*}
The preservation morphisms are as follows. Note that $\emptycon_{\bU} = \top$ and $\ext_{\bU}$ is
metatheoretic $\Sigma$.
\begin{alignat*}{3}
  &(\bPiinf\,A\,\bb)_{\emptycon}^{-1} && : \top\ra (\bPiinf\,A\,\bb)\,\emptycon\\
  %% &                               && : \top\ra (a : A) \ra \bb\,a\,\emptycon\\
  &(\bPiinf\,A\,\bb)_{\emptycon}^{-1} && :\equiv \lambda\,\_\,a.\,(\bb\,a)_{\emptycon}^{-1}\,\tt\\
  &(\bPiinf\,A\,\bb)_{\ext}^{-1} && : (\Gamma : (\bPiinf\,A\,\bb)\,\ulGamma)\times((\bPiinf\,A\,\bb)\,\ulA\,\Gamma)\\
  & && \hspace{0.5em}\ra (\bPiinf\,A\,\bb)\,(\ulGamma \ext \ulA)\\
  & (\bPiinf\,A\,\bb)_{\ext}^{-1} && :\equiv \lambda\,(\Gamma,A)\,a.\,(\bb\,a)_{\ext}^{-1}(\Gamma\,a,\,A\,a)
\end{alignat*}

The preservation of $\emptycon$ and $\blank\ext\blank$ here is in fact the main
point of divergence from \cite{kaposi2019constructing}. In ibid., substitutions
and terms are modeled as strict morphisms and types as displayed CwFs (with no
iso-cleaving). However, it is not the case that $(\bPiinf\,A\,\bb)\,\emptycon =
\top$, which is the statement of strict $\emptycon$-preservation. The left side
reduces to $(a : A)\ra \bb\,a\,\emptycon$, which is isomorphic to $\top$ but not
strictly equal to it. Likewise for $\ext$-preservation.

Hence, we are forced to
interpret terms as weak sections, which in turn forces us to interpret
types as isofibrations, since type substitution requires iso-cleaving.

\subsection{Identity}
For $\bt$ and $\bu$ in $\bTm\,\bGamma\,(\bEl\,\ba)$, we define $\bId\,\bt\,\bu
\boldsymbol{:} \bTm\,\bGamma\,\bU$ as expressing pointwise equality of weak
sections.
\begin{alignat*}{3}
& (\bId\,\bt\,\bu)\,\ulGamma &&:\equiv \bt\,\ulGamma = \bu\,\ulGamma\\
& (\bId\,\bt\,\bu)\,\ulA     && :\equiv \lambda\,e.\, \bt\,\ulA = \bu\,\ulA
\end{alignat*}
Above, $\bt\,\ulA = \bu\,\ulA$ is well-typed because of $e :
\bt\,\ulGamma = \bu\,\ulGamma$. For substitutions, we have to complete a square
of equalities:
\begin{alignat*}{3}
  (\bId\,\bt\,\bu)\,(\ulsigma : \Sub\,\ulGamma\,\ulDelta) : \bt\,\ulGamma = \bu\,\ulGamma \ra
       \bt\,\ulDelta = \bu\,\ulDelta
\end{alignat*}
This can be given by $\bt\,\ulsigma : \ba\,\ulsigma\,(\bt\,\ulGamma) =
\bt\,\ulDelta$ and $\bu\,\ulsigma : \ba\,\ulsigma\,(\bu\,\ulGamma) =
\bu\,\ulDelta$. The action on terms is analogous. We omit preservation morphisms
here as they are straightforward. Like $\bPiinf$, $\bId$ also does not support
strict preservation of $\emptycon$ and $\ext$. Equality reflection and $\boldsymbol{\refl :}
\bId\,\bt\,\bt$ are also evident.

With this, we have defined the $\bM_{i,j} : \ToS_{\max(i+1,j)+1, j}$ model that
we set out to define in Section \ref{sec:overview}.

\section{Model Theory of the Theory of Signatures}
\label{sec:tossig}

At this point, we only have a notion of algebra for ToS, from Definition
\ref{def:tos}. In the following sections, we would also like to talk about
initial ToS-algebras and ToS-induction. We get these notions by giving a QIIT
signature for ToS, and interpreting it in the $\bM$ model from the previous
section.

\begin{definition}[Signature for ToS] For each level $j$,
we define $\ToSSig_j : \Sig_{j+i}$, as the signature for the theory of
signatures with external sets in $\Set_j$. This is a large and infinitary QIIT
signature, as we have $\Pie$ and $\Piinf$ abstracting over $A : \Set_j$ and
branching with $A \ra \Ty\,\Gamma$ and $A \ra \Tm\,\Gamma\,\U$ respectively. We
present an excerpt from $\ToSSig_i$ below.
\begin{alignat*}{3}
  & \emptycon && \ext (Con : \U)\\
  &           && \ext (Sub : Con\arri Con \arri \U)\\
  &           && \ext (Ty  : Con\arri\U)\\
  &           && \ext (Tm  : \Pii(\Gamma : Con)(\Ty\,\Gamma \arri \U))\\
  &           && ...\\
  &           && \ext (\Piinf : \Pii(\Gamma : Con)\\
  &           && \hspace{4.2em}(\Pie \Set_j (\lambda\,A.\,(A \arrinf \Ty\,\Gamma)\arri\El(\Ty\,\Gamma))))\\
  &           && ...
\end{alignat*}
\end{definition}

Now, for each $i$, the interpretation of $\ToSSig_j$ in $\bM_{i,j+1}$ yields an
flCwF $\bGamma$ such that $\Con_{\bGamma} = \ToS_{i,j}$. In short, we can
recover ToS algebras from the semantics of $\ToSSig$. This follows by
computation of the interpretation and the fact that $\ToSSig$ is precisely the
internal representation of $\ToS$. Hence, we have self-description modulo the
bumping of the $j$ level. Also, as we get an flCwF of $\ToS_{i,j}$-algebras, we
can use Definition \ref{def:induction} for the notion of $\ToS$-induction.

\emph{Remark.} By the definition of $\bemptycon$ and
$\boldsymbol{\blank\ext\blank}$, the types of algebras computed by $\bM$ are
always left-nested iterated $\Sigma$-types which start with $\top$. Hence, we
need to require that Definition \ref{def:tos} is similarly left-nested and
starts with $\top$, in order to make the match strict.

\section{Term Models of QIITs}
\label{sec:termmodels}

In this section we construct QIITs from initial ToS-algebras. For this, we need
to assume the existence of such algebras.

\subsection{Assuming Syntax for the Theory of Signatures}

\begin{lemma}[Cumulativity of $\ToS$]\label{lemma:cumulativity} If $i \leq i'$, then $\ToS_{i,j} \leq \ToS_{i', j}$.
  This follows from the definition of ToS and the subtyping rules in Section
  \ref{sec:cumulativity}. \qed
\end{lemma}

\textbf{Assumption.} For each level $j$ and $j'$ such that $j+1 \leq j'$, we
assume the existence of $\syn_j : \ToS_{j+1,j}$, and we assume that $\syn_j$,
considered as an element of $\ToS_{j',j}$ by Lemma \ref{lemma:cumulativity}, is
inductive in the sense of Definition \ref{def:induction}.

We explain this assumption. The syntax for the theory of signatures is
postulated at the lowest possible level $\ToS_{j+1,j}$. This is the lowest
because signatures may contain $A : \Set_j$ types, and since we want to view the
syntax as freely generated, its inductive sorts must be large enough to contain
the $A$ types. Otherwise we would run into Russell's paradox. Then, the
induction assumption says that we have induction at all levels larger than
$j+1$.

\begin{example} We have $\syn_0 : \ToS_{1, 0}$, which is the syntax of closed QIIT signatures. We want to define a function $\mathsf{length} : \Con_{\syn_0} \ra \mathbb{N}$ by induction, which returns the length of a syntactic context as a metatheoretic natural number. To this end, we define a displayed ToS over $\syn_0$, where $\Con$ is defined as constantly $\mathbb{N}$, every other sort is defined as constantly $\top$, $\emptycon$ is defined as $0$ and $\Gamma\ext A$ is defined as $\Gamma + 1$. By the induction assumption, we get a ToS-section from $\syn_0$ to the displayed model, whose action on contexts is exactly the $\mathsf{length}$ function. Note that the induction assumption requires that the displayed model is at least at level 1, but this is not problematic because by cumulativity $\mathbb{N} : \Set_1$.
\end{example}

With $\syn$ at hand, we can use an alternative, more conventional representation of
signatures.

\begin{definition} We define $\SynSig_j : \Set_{j+1}$, the type of \emph{syntactic signatures} at $j$, as $\Con_{\syn_j}$.
\end{definition}

We can convert a signature to a syntactic one by interpreting it in some
$\syn_j$ model, and we can convert in the other direction by using ToS-induction
to interpret a $\Gamma : \Con_{\syn_j}$ in an arbitrary ToS model.

\subsection{Term Algebras}

The basic idea is that initial algebras can be built from the terms of $\syn_j$.
For example, consider the syntactic signature for natural numbers:
\[
\NatSig :\equiv \emptycon\ext(N : \U)\ext(zero : \El\,N)\ext (suc : N
\arri \El\,N)
\]
The type $\Tm_{\syn}\,\NatSig\,(\El_{\syn}\,N)$ is isomorphic to the usual type
of natural numbers, since, intuitively, such terms can only be built from
iterated usage of $zero$ and $suc$. We will build a term algebra for each
signature in this manner. First, we describe the interpretation of $\syn$ in the
$\Set$ model.

\begin{definition}[The $\Set$ model of $\ToS$] For each $j$, we have $\bS : \ToS_{j+1, j}$, which can be given by restricting the $\bM$ model
of Section \ref{sec:semantics} so that we only have the first $\Con$ components
in the interpretations for contexts, substitution, types, term, and we only have
actions on contexts in the interpretations of term and substitution
formers. Hence, we have:
\begin{alignat*}{3}
  & \Con_{\bS} && :\equiv \Set_{j+2} \\
  & \Sub_{\bS}\,\Gamma\,\Delta && :\equiv \Gamma \ra \Delta\\
  & \Ty_{\bS}\,\Gamma && :\equiv \Gamma \ra \Set_{j+2}\\
  & \Tm_{\bS}\,\Gamma\,A && :\equiv (\gamma : \Gamma) \ra A\,\gamma
\end{alignat*}
\end{definition}

For every $M : \ToS_{j+1,j}$, there is a unique strict $\ToS$-morphism from
$\syn_j$ to $M$. This follows from the induction assumption on $\syn_j$ and
Theorem \ref{thm:initialind}. We denote this morphism as
$\llbracket\blank\rrbracket_M$.  For example, given $\Gamma : \Con_\syn$, we
have $\llbracket\Gamma\rrbracket_M : \Con_M$.  Also, for every displayed
$\ToS$-model $M$ over $\syn_j$, there is a strict $\ToS$-section of $M$. We also
denote this as $\llbracket\blank\rrbracket_M$, so e.g.\ for $\ulGamma :
\Con_\syn$ we have $\llbracket\ulGamma\rrbracket_M : \Con_M\,\ulGamma$.

For a syntactic signature $\Gamma$, $\llb\Gamma\rrb_{\bS}$ yields exactly the
type of $\Gamma$-algebras, e.g.\ $\llb\NatSig\rrb_{\bS}$ is a left-nested
$\Sigma$-type, which is the type of pointed sets with an endofunction.

\begin{definition}[Term algebra construction]
For each syntactic signature $\ulOmega : \SynSig_j$, we define a displayed $\ToS$
model over $\syn_j$, named $\bT$. The underlying sets are as follows:
\begin{alignat*}{3}
  & \Con\,\ulGamma :\equiv \Sub_{\syn}\,\ulOmega\,\ulGamma \ra \llb\ulGamma\rrb_{\bS}
\end{alignat*}



\end{definition}







\section{Related Work}
\label{sec:relatedwork}

\section{Conclusion}
\label{sec:conclusion}


%% Acknowledgments
\begin{acks}
This work was supported by the European Union, co-financed by the
European Social Fund (EFOP-3.6.3-VEKOP-16-2017-00002) and COST Action
EUTypes CA15123.
\end{acks}


%% Bibliography
\bibliography{references}

\end{document}

%% B : Set j

%% (A : Set_i) -> B

%% A : Seti
%% B : Set j
%% (x : A) -> B : Set(max i j)

%% (Con : Setj)x
%% (Ty  : Con -> Setj)x

%% (Pie : (A : Seti) -> (A -> Ty Gamma) -> Ty Gamma
%% : Set(max(suci, j))

%% : Set(max(sucj, max(suci,j)))
%%    max(1+j, max(1+i, j))
%%  = max(1+i, 1+j)

%% REVISE LEVELS!!

%% syntax levels:

  %% ToS(i, 1+i) : Set(max(1+i, 2+i))

%% REWRITE metatheory


%% write about limitations!
