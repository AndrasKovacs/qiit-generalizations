%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[PL'18]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2018}{New York, NY, USA}
\acmYear{2018}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


%% ------------------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathpartir}
\usepackage{scalerel}


\usepackage{tikz-cd}


\newtheorem{notation}{Notation}

\input{abbrevs.tex}
\newcommand{\Lift}{\Uparrow}
\newcommand{\ToS}{\mathsf{ToS}}
\newcommand{\ext}{\triangleright}
\newcommand{\emptycon}{\scaleobj{.75}\bullet}
\newcommand{\Pii}{\Pi}
\newcommand{\appi}{\mathsf{app}}
\newcommand{\lami}{\mathsf{lam}}
\newcommand{\Pie}{\Pi^{\mathsf{ext}}}
\newcommand{\appe}{\mathsf{app^{ext}}}
\newcommand{\lame}{\mathsf{lam^{ext}}}
\newcommand{\Piinf}{\Pi^{\mathsf{inf}}}
\newcommand{\appinf}{\mathsf{app^{inf}}}
\newcommand{\laminf}{\mathsf{lam^{inf}}}
\newcommand{\appitt}{\mathop{{\scriptstyle @}}}
\newcommand{\Refl}{\mathsf{Refl}}
\newcommand{\IdU}{\mathsf{IdU}}
\newcommand{\ReflU}{\mathsf{ReflU}}
\newcommand{\Sig}{\mathsf{Sig}}
\newcommand{\Sg}{\Sigma}
\newcommand{\flCwF}{\mathsf{flCwF}}
\newcommand{\Kfam}{\mathsf{K}}
\newcommand{\p}{\mathsf{p}}
\newcommand{\q}{\mathsf{q}}
\newcommand{\lamK}{\mathsf{lam}^{\K}}
\newcommand{\appK}{\mathsf{app}^{\K}}

\newcommand{\arri}{\Rightarrow}
\newcommand{\arre}{\Rightarrow^{\mathsf{ext}}}
\newcommand{\arrinf}{\Rightarrow^{\mathsf{inf}}}

\newcommand{\bCon}{\boldsymbol{\Con}}
\newcommand{\bTy}{\boldsymbol{\Ty}}
\newcommand{\bSub}{\boldsymbol{\Sub}}
\newcommand{\bTm}{\boldsymbol{\Tm}}
\newcommand{\bGamma}{\boldsymbol{\Gamma}}
\newcommand{\bDelta}{\boldsymbol{\Delta}}
\newcommand{\bsigma}{\boldsymbol{\sigma}}
\newcommand{\bdelta}{\boldsymbol{\delta}}
\newcommand{\bepsilon}{\boldsymbol{\epsilon}}
\newcommand{\bt}{\boldsymbol{t}}
\newcommand{\bu}{\boldsymbol{u}}
\newcommand{\bA}{\boldsymbol{A}}
\newcommand{\ba}{\boldsymbol{a}}
\newcommand{\bb}{\boldsymbol{b}}
\newcommand{\bB}{\boldsymbol{B}}
\newcommand{\bid}{\boldsymbol{\id}}
\newcommand{\bemptycon}{\boldsymbol{\emptycon}}
\newcommand{\bSet}{\boldsymbol{\Set}}
\newcommand{\bU}{\boldsymbol{\U}}
\newcommand{\bEl}{\boldsymbol{\El}}
\newcommand{\bPii}{\boldsymbol{\Pi}}
\newcommand{\bPie}{\boldsymbol{\Pie}}
\newcommand{\bPiinf}{\boldsymbol{\Piinf}}
\newcommand{\bappi}{\boldsymbol{\mathsf{app}}}
\newcommand{\blami}{\boldsymbol{\mathsf{lam}}}

\newcommand{\ul}[1]{\underline{#1}}
\newcommand{\ulGamma}{\ul{\Gamma}}
\newcommand{\ulDelta}{\ul{\Delta}}
\newcommand{\ulgamma}{\ul{\gamma}}
\newcommand{\uldelta}{\ul{\delta}}
\newcommand{\ulsigma}{\ul{\sigma}}
\newcommand{\ulepsilon}{\ul{\epsilon}}
\newcommand{\ult}{\ul{t}}
\newcommand{\ulu}{\ul{u}}
\newcommand{\ulA}{\ul{A}}
\newcommand{\ulB}{\ul{B}}

\newcommand{\coe}{\mathsf{coe}}
\newcommand{\coh}{\mathsf{coh}}


%% ------------------------------------------------------------



\begin{document}

%% Title information
\title{Large and Infinitary Quotient Inductive-Inductive Types} %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%% \titlenote{with title note}             %% \titlenote is optional;
%%                                         %% can be repeated if necessary;
%%                                         %% contents suppressed with 'anonymous'
%% \subtitle{Subtitle}                     %% \subtitle is optional
%% \subtitlenote{with subtitle note}       %% \subtitlenote is optional;
%%                                         %% can be repeated if necessary;
%%                                         %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

\author{Andr{\'a}s Kov{\'a}cs}
\orcid{0000-0002-6375-9781}
\affiliation{
  \department{Department of Programming Languages and Compilers}
  \institution{E{\"o}tv{\"o}s Lor{\'a}nd University}
  \city{Budapest}
  \country{Hungary}                   %% \country is recommended
}
\email{kovacsandras@inf.elte.hu}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Quotient inductive-inductive types (QIITs) are generalized inductive types which
allow sorts to be indexed over previously declared sorts, and allow usage of
equality constructors. QIITs are especially useful for algebraic descriptions of
type theories and constructive definitions of real, ordinal and surreal
numbers. We develop new metatheory for large QIITs, large elimination, recursive
equations and infinitary constructors. As in prior work, we describe QIITs using
a type theory where each context represents a QIIT signature. However, in our
case the theory of signatures can also describe its own signature, modulo
universe sizes. We bootstrap the model theory of signatures using
self-description and a Church-coded notion of signature, without using
complicated raw syntax or assuming an existing internal QIIT of signatures. We
give semantics to described QIITs by modeling each signature as a finitely
complete CwF (category with families) of algebras. Compared to the case of
finitary QIITs, we additionally need to show invariance under algebra
isomorphisms in the semantics. We do this by modeling signature types as
isofibrations. Finally, we show by a term model construction that every QIIT is
constructible from the syntax of the theory of signatures.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003790.10011740</concept_id>
<concept_desc>Theory of computation~Type theory</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{inductive types, quotient inductive-inductive types}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

\todo{P and Q in cwf, level lifts, think about revising cETT or compressing}

The aim of this work is to provide theoretical underpinning to a general notion
of inductive types, called quotient inductive-inductive types (QIITs). QIITs are
of interest because there are many commonly used mathematical structures, which
can be conveniently described as QIITs in type theory, but cannot be defined as
less general inductive types, or doing so incurs large encoding overhead.

Categories are a good example. Signatures for QIITs allow having multiple sorts,
with later ones indexed over previous ones, and equations as well. We need both
features in order to write down the signature of categories.

The benefit of having a QIIT signature is getting a model theory ``for free'',
from the metatheory of QIITs. This model theory includes a category of algebras
which has an initial object and also some additional structure. For the
signature of categories, we get the empty category as the initial object, but it
is common to consider categories with more structure, which have more
interesting initial models.

Algebraic notions of models of type theories are examples for this. Here,
initial models represent syntax, and initiality corresponds to induction on
syntax. Several variants have been used, from contextual categories \cite{TODO} and
comprehension categories \cite{TODO} to categories with families \cite{TODO}, but all of these are
categories with extra structure.

The main motivation of the current paper is to generalize previously formalized
\cite{kaposi2019constructing} QIITs so that they accommodate more algebraic
formulations of type theories, and more aspects of their practical
metatheory. As a side effect of fulfilling this goal, infinitary QIITs such as
Cauchy real numbers \cite{TODO} are covered as well.

\subsection{Contributions}

We add the following features to QIITs:
\begin{enumerate}
  \item
  \textbf{Large constructors, large elimination} and algebras at different
  universe levels. Large elimination is routinely used in the metatheory of type
  theory, but it has not been presented explicitly in previous works about
  QIITs.
  \item
  \textbf{Infinitary constructors}. This allows infinitely branching
  trees. Also, the theory of QIIT signatures is itself large and infinitary,
  thus it can ``eat itself'', i.e.\ include its own signature and provide
  its own metatheory. This was not possible previously in
  \cite{kaposi2019constructing}, where only finitary QIITs were described. We
  exploit self-representation to bootstrap the model theory of signatures,
  without having to assume any pre-existing internal syntax.
  \item
  \textbf{Recursive equations}, i.e. equations appearing as assumptions
  of constructors. These have occurred previously in syntaxes of cubical type
  theories, as boundary conditions\cite{TODO}.
\end{enumerate}

To provide semantics, we show that for each signature, there is a CwF (category
with families) of algebras, extended with $\Sigma$-types, extensional identity,
and constant families. This additional structure corresponds to a type-theoretic
flavor of finite limits, as it was shown in \cite{clairambault2014biequivalence}
that the category of such CwFs is biequivalent to the category of finitely
complete categories.

Compared to the case of finitary QIITs, the addition of infinitary constructors
and recursive equations requires a significant change in semantics: instead of
strict CwF morphisms, we need to consider weak ones, and instead of modeling
types as displayed CwFs, we need to model them as CwF isofibrations. In a
nutshell, the new semantics must be given mutually with a form of a ``structure
identity principle''\cite{TODO}, which says that signature extension respects algebra
isomorphisms.

We also show, by a term model construction, that all QIITs are reducible to the
syntax of signatures. This construction also essentially relies on invariance under
isomorphisms.

\subsection{Outline of the Paper}

In Section \ref{sec:metatheory}, we describe a cumulative variant of extensional type
theory which is used as metatheory in the rest of the paper. In Section \ref{sec:tos},
we introduce the theory of QIIT signatures. TODO

\section{Metatheory}

In this paper we consider QII algebras at arbitrary finite levels, along with
large eliminations, where the initial algebra can be at a different level than
the target algebra. For a simple example, consider natural number algebras at
level $i$, given as the $\Sigma$-type $NatAlg_i :\equiv(Nat : \Set_i)\times
Nat\times(Nat \ra Nat)$. The initial such algebra is the set of natural numbers,
which is at level $0$, but in type theory we often want to eliminate into larger
$\Set_i$, for example when computing a $Nat$-indexed family of types. To support
convenient reasoning about levels in this paper, we need two features:
cumulativity and a way to quantify over finite levels. The former is essential
to reduce bureaucratic overhead, while the latter is required to talk about
arbitrary levels.

\subsection{Cumulativity}

%% Cumulativity makes handling of algebras and constructions at different levels
%% much easier. For example, given an algebra $\gamma : NatAlg_i$, cumulativity
%% allows us to also have $\gamma : NatAlg_{i+j}$. In a non-cumulative setting such
%% as Agda, we may only have for each type $A : \Set_i$ a type $\mathsf{Lift}_{i\,j}\,A :
%% \Set_{i+j}$ which is isomorphic to $A$ up to definitional equality.

In its most basic form, cumulativity requires that whenever $A : \Set_i$, and $i
< j$ then also $A : \Set_j$. We also need cumulativity for $\Sigma$ and function
types, in order to have cumulativity for QII algebras in general. For example,
we want to have $\gamma : NatAlg_j$ whenever $\gamma : NatAlg_i$ and $i < j$.

We use Sterling's cumulative algebraic type theory \cite{sterling2019algebraic} as basis for our metatheory. \todo{REASONS, revamp}

%% The reason is that it is the only rigorous
%% algebraic definition of cumulativity that we are aware of, and it also

%% The reason for this is twofold. First, it
%% supports the right kind of cumulativity for our purposes. Second, it is itself a
%% finitary QIIT with sort equations, hence this paper provides a model theory for
%% it

We extend the base theory with an extensional identity type, $\Sigma$-types and
the unit type. In \cite{sterling2019algebraic} a proof of canonicity is provided for the base
theory, which also includes a standard set-theoretic model. It is
straightforward to extend the canonicity proof to cover our additional type
formers.

From now on, we refer to this theory as cETT (cumulative extensional type
theory). When working in cETT, we use the following notation. We have
Russell-style universes $\Set_i$ indexed by natural numbers, dependent functions
as $(x : A)\ra B$, and dependent pairs as $(x : A)\times B$ with projections
$\proj1$ and $\proj2$. We sometimes leave parameters implicit in dependent
function types, e.g.\ write $\id : A \ra A$ instead of $\id : (A : \Set_i)\ra A
\ra A$. We also use subscripts as a field projection notation for iterated
pairs. For example, for $t : (A : \Set_i) \times (B : \Set_i) \times (f : A \ra
B)$, we use $B_t$ to denote the projection of the second component. Sometimes we
omit the subscript if it is clear from context. When we write ``exists'' in this
paper, we always mean chosen structure given by a $\Sigma$-type.

We write propositional equality as $t = u$, with $\refl_t$ for reflexivity. We
have equality reflection and uniqueness of identity proofs (UIP) for
$\blank=\blank$. The unit type is $\top$, with inhabitant $\tt$.

\todo{compactify cumulativity}

\begin{figure}
\begin{mathpar}
  \inferrule*[lab=universe formation]
             {i < j}
             {\Gamma \vdash \Set_i : \Set_{j}}

  \inferrule*[lab=function formation]
             {\Gamma \vdash A : \U_i \\ \Gamma,\,x : A \vdash B : \U_j}
             {\Gamma \vdash (x : A)\ra B : \U_{\max(i,j)} }

  \inferrule*[lab=$\Sigma$ formation]
             {\Gamma \vdash A : \U_i \\ \Gamma,\,x : A \vdash B : \U_j}
             {\Gamma \vdash (x : A)\times B : \U_{\max(i,j)} }

  \inferrule*[lab=unit formation]
             {\\}
             {\Gamma \vdash \top : \Set_i}

  \inferrule*[lab=equality formation]
             {\Gamma \vdash A : \Set_i \\ \Gamma \vdash t : A \\ \Gamma \vdash u : A}
             {\Gamma \vdash t = u : \Set_i}

  \inferrule*[lab=type lifting]
             {\Gamma \vdash A : \Set_i \\ i \leq j}
             {\Gamma \vdash\,\Lift_j A : \Set_{j}}

  \inferrule*[lab=lift composition]{}{\Lift_j (\Lift_i A) \equiv\,\,\Lift_{j} A}


  \inferrule*[lab=identity lift]{\Gamma \vdash A : \Set_i}{(\Lift_i A) \equiv\,A}

  \inferrule*[lab=term lifting]
             {}
             {\{t\,|\,\Gamma \vdash t : A\} \equiv \{t\,|\,\Gamma \vdash t :\,\,\Lift_i A\}}

  \inferrule*[lab=context lifting]
             {}
             {(\Gamma,\,x : A) \equiv (\Gamma,\,x :\,\,\Lift_i A)}

  \inferrule*[lab=universe lifting]{}{\Lift_j \Set_i \equiv \Set_i}

  \inferrule*[lab=function lifting]
             {}
             {\Lift_i((x : A)\ra B) \equiv (x :\,\Lift_i A)\ra\,\Lift_i B}

  \inferrule*[lab=pair lifting]
             {}
             {\Lift_i((x : A)\times B) \equiv (x :\,\Lift_i A)\,\times\Lift_i B}

  \inferrule*[lab=unit lifting]
             {}
             {\Lift_i\top \equiv \top}

  \inferrule*[lab=equality lifting]
             {}
             {\Lift_i(t = u) \equiv (t = u)}
\end{mathpar}

\caption{Some of the rules for lifting.}
\label{lifting}
\end{figure}

We also have a lifting operation on types, which introduces cumulativity. In
Figure \ref{lifting}, we include an excerpt of cETT's rules. We change
presentation slightly from Sterling: we use a $\U_{\max(i,j)}$ return type in
functions and pairs, instead of having both $A$ and $B$ types in the same
$\Set_i$, and we define type lifting with $i \leq j$ instead of $i < j$. These
changed rules are all derivable from the original ones. In general, we can
expect that lifting never impedes constructions, because it appropriately
computes out of the way.

Of special note is the \emph{term lifting rule}. It is a sort equation, an
equation between sets of terms, expressing that lifted types have exactly the
same terms as unlifted ones. This allows us to have $t :\,\,\Lift_j A$ whenever $t
: A$. Together with the universe lifting rule, this implies $A : \Set_{i+j}$
whenever $A : \Set_i$. Similarly, the lifting rules for functions and pairs give
us cumulativity for $NatAlg$. We derive a notion of subtyping:

\begin{definition}[Cumulative subtyping]
  For $A : \Set_i$, $i \leq j$ and $B : \Set_{j}$, we define $A \leq B : \Set_{j}$
  as $B =\,\,\Lift_j A$.  It follows from term lifting and equality reflection
  that whenever $A \leq B$ and $t : A$, then also $t : B$.
\end{definition}

\subsection{Universe Polymorphism}
\label{sec:universe_polymorphism}

For the sake of simplicity, we do not add this to cETT directly. Instead, we
quantify over levels in an unspecified metatheory \emph{outside} cETT. Hence, a
universe polymorphic cETT term is understood as a $\mathbb{N}$-indexed family of
terms. We reuse the notation of cETT functions for universe polymorphism, e.g.\ as
in the following function:
\[
\lambda\,i.\,\Set_i : (i : \mathbb{N})\ra \Set_{i+1}
\]
In this paper, we do not need to internalize level-polymorphic constructions,
so this setup is sufficient.

\section{QIIT Signatures}
\label{sec:tos}

Signatures are given as contexts in a certain type theory, the theory of
signatures. We shall abbreviate it as ToS. However, ToS turns out to be a large
infinitary QIIT itself, and we would like to define ToS and a notion of
signature without referring to QIITs, only using features present in cETT. As a
first step, we define a notion of model.

\begin{definition}[Notion of model for the theory of signatures]\label{def:tos}
For levels $i$ and $j$, $\ToS_{i,j} : \Set_{\max(i,\,j)+1}$ is a cETT type whose
elements are ToS models (or ToS-algebras). $\ToS_{i,j}$ is an iterated
$\Sigma$-type, containing all of the following components.

A \textbf{category with families} (CwF), where all four underlying sets (of
objects, morphisms, types and terms) are in $\Set_j$. Following notation in
\cite{kaposi2019constructing}, we denote these respectively as $\Con : \Set_j$,
$\Sub : \Con \ra \Con \ra \Set_j$, $\Ty : \Con \ra \Set_j$ and $\Tm : (\Gamma :
\Con) \ra \Ty\,\Gamma \ra \Set_j$. We use $\id$ and $\blank\circ\blank$ to
denote identity and composition for substitution. We denote the empty context as
$\emptycon : \Con$, and the unique substitution into the empty context as
$\epsilon : \Sub\,\Gamma\,\emptycon$. Context extension is $\blank\ext\blank :
(\Gamma : \Con)\ra \Ty\,\Gamma \ra \Con$. Substitution on types and terms is
written as $\blank[\blank]$. Projections are noted as $\p :
\Sub\,(\Gamma\,\ext\,A)\,\Gamma$ and $\q : \Tm\,(\Gamma\,\ext\,A)\,(A[\p])$, and
substitution extension is $\blank,\blank : (\sigma : \Sub\,\Gamma\,\Delta)\ra
\Tm\,\Gamma\,(A[\sigma])\ra \Sub\,\Gamma\,(\Delta\ext A)$.

A \textbf{universe} $\U : \Ty\,\Gamma$ with decoding $\El : (a :
\Tm\,\Gamma\,\U) \ra \Ty\,\Gamma$.

\textbf{Inductive function space} $\Pii : (a : \Tm\,\Gamma\,\U) \ra
\Ty\,(\Gamma\,\ext\,\El\,a) \ra \Ty\,\Gamma$, with application as $\appi :
\Tm\,\Gamma\,(\Pii\,a\,B)\ra \Tm\,(\Gamma\,\ext\,\El\,a)\,B$ and its
inverse $\lami$.

\textbf{External function space} $\Pie : (A : \Set_i)\ra(A \ra \Ty\,\Gamma)\ra
\Ty\,\Gamma$, with $\appe : \Tm\,\Gamma\,(\Pie\,A\,B)\ra((x : A)\ra
\Tm\,\Gamma\,(B\,x))$ and its inverse $\lame$.

\textbf{Infinitary function space} $\Piinf : (A : \Set_i)\ra(A \ra
\Tm\,\Gamma\,\U)\ra \Tm\,\Gamma\,\U$, with $\appinf :
\Tm\,\Gamma\,(\El\,(\Pie\,A\,b))\ra((x : A)\ra \Tm\,\Gamma\,(\El\,(b\,x)))$ and
its inverse $\laminf$.

\textbf{An identity type} $\Id : (a : \Tm\,\Gamma\,\U)\ra
\Tm\,\Gamma\,(\El\,a)\ra\Tm\,\Gamma\,(\El\,a)\ra \Tm\,\Gamma\,\U$, with $\Refl :
(t : \Tm\,\Gamma\,(\El\,a))\ra \Id\,a\,t\,t$, equality reflection and UIP.

\end{definition}
In the above listing, we omit equations for substitution and
$\beta\eta$-conversion, but these should be understood to be also part of
$\ToS_{i,j}$.

\emph{Notational conventions.} We name elements of $\Con$ as $\Gamma$, $\Delta$,
$\Theta$, elements of $\Sub\,\Gamma\,\Delta$ as $\sigma$, $\delta$, $\nu$,
elements of $\Ty\,\Gamma$ as $A$, $B$, $C$, and elements of $\Tm\,\Gamma\,A$ as
$t$, $u$, $v$. CwF components by default support de Bruijn indices, which are
not easily readable. We use instead a nameful notation for binders in context
extension, $\Pii$ and $\lami$, e.g.\ as $(\emptycon\,\ext (a : U) \ext (t :
\El\,a))$. We also define a type-theoretic flavor of $\appi$ for convenience:
\begin{alignat*}{3}
  & \blank\appitt\blank && :
      \Tm\,\Gamma\,(\Pii\,a\,B)\ra
      (u : \Tm\,\Gamma\,(\El\,a)) \ra \Tm\,\Gamma\,(B[\id, u])\\
  & t\appitt u && :\equiv (\appi\,t)[\id, u]
\end{alignat*}
We abbreviate non-dependent inductive $\Pii$ as $\blank\arri\blank$, and likewise we use $\blank\arre\blank$ and $\blank\arrinf\blank$.

%% We use abbreviations for non-dependent function types:
%% \begin{alignat*}{3}
%%   & A\arri B && :\equiv \Pi\,A\,(B[\p])\\
%%   & A \arre\,B &&:\equiv \Pie\,A\,(\lambda\,\_.\,B) \\
%%   & A \arrinf\,B &&:\equiv \Piinf\,A\,(\lambda\,\_.\,B)
%% $A\arri B :\equiv \Pi\,A\,(B[\p])$, and $A \arre\,B :\equiv \Pie\,A\,(\lambda\,\_.\,B)$, and likewise
%% $A \arrinf\,B :\equiv \Piinf\,A\,(\lambda\,\_.\,B)$.

\begin{definition}[Notion of signature]
A QIIT signature at level $i$ is a context in an arbitrary $M : \ToS_{i,j}$
model. We define the type of such signatures as follows:
\[
  \Sig_i :\equiv (j : \mathbb{N})\ra(M : \ToS_{i,j})\ra Con_M
\]

Here, $i$ refers to the level of external types appearing in the signature, in
the domains of $\Pie$ and $\Piinf$ functions, while the quantified $j$ level is
required to allow interpreting a signature in arbitrary-sized ToS models. Note
that $\Sig_i$ is universe-polymorphic, so it is a family of cETT types and it is
not in any cETT universe.

\begin{example}{
    Signature for natural numbers. Here, no external types appear, so the level
    can be chosen as $0$.}
\begin{alignat*}{3}
  & NatSig : \Sig_0 \\
  & NatSig :\equiv \lambda (j :\mathbb{N})(M : \ToS_{0,j}).\\
  & \hspace{1em}(\emptycon_M\,\ext_M\, (N : \U_M) \,\ext_M\,(zero : \El_M\,N)\\
  & \hspace{2.67em}\ext_M (suc : N\arri_M\El_M\,N))
\end{alignat*}
\end{example}

With this, we are able to specify QIITs, and we can also interpret each
signature in an arbitrary ToS model, by applying a signature to a model.
$\Sig_i$ can be viewed as a precursor to a Church-encoding for the theory of
signatures, but we only need contexts encoded in this way, and not other ToS
components. In functional programming, this is sometimes called
``finally tagless''\cite{carette2007finally}, and it is used for defining and
interpreting embedded languages.
\end{definition}

In the following examples, we leave the abstracted $M : \ToS_{i,j}$ implicit.

\begin{example}{Infinitary constructors}. The universe $\U$ is closed under
the $\Piinf$ function type, which allows such functions to appear in the domains
of $\Pii$ types. This allows, for example, a signature for trees branching with
arbitrary small sets. This is a signature at level 1, since we have $\Set_0$ as
a $\Pie$ domain type.
\begin{alignat*}{3}
& TreeSig :\equiv \\
& \hspace{1em}\emptycon \ext (Tree : \U)\\
& \hspace{1.35em}\ext (node : \Pie\,\Set_0\,(\lambda A.\,(A\,\arrinf\,Tree)\arri\El\,Tree))
\end{alignat*}
\end{example}

%% \begin{example}{Sort equations}. An interesting example is the term lifting
%% rule for cETT (omitting everything except term lifting):
%% \begin{alignat*}{3}
%%   & cETTSig :\equiv \\
%%   & ...\,\ext\,Tm{\Lift} : \Pii\,(\Gamma : Con)\,(\Pii\,(A : Ty{\appitt}\Gamma)((\IdU\,(Tm{\appitt}\Gamma{\appitt}A)\,(Tm{\appitt}\Gamma{\appitt}(\Lift_j{\appitt}A))))
%% \end{alignat*}
%% \end{example}

\begin{example}{Recursive equations}. Again, the universe is closed under $\Id$, which allows us to write equations
in $\Pii$ domains. A minimal example:
\begin{alignat*}{3}
  & RecEqSig :\equiv\\
  & \hspace{0.5em}\emptycon\,\ext (A : \U) \ext (a : \El\,A)\ext (f : \Pii\,(x : A)\,(\Id\,A\,x\,a\arri\El\,A))
\end{alignat*}
More interesting (and complicated) examples are boundary conditions in various
cubical type theories\cite{TODO}. Note that our $\Id$ allows iterated equations
as well, but these are all trivial in the semantics, where we assume UIP.
\end{example}

\section{Semantics}
\label{sec:semantics}

\subsection{Overview}

For each signature, we would like to have at least
\begin{enumerate}
  \item A category of algebras, with homomorphisms as morphisms.
  \item A notion of induction, which requires a notion of dependent algebras.
  \item A proof that for algebras, initiality is equivalent to supporting induction.
\end{enumerate}

Following \cite{kaposi2019constructing}, we do this by creating a model of ToS,
where contexts are categories supporting the above requirements and
substitutions are appropriate structure-preserving functors. Then, each
signature can applied to this model, yielding an interpretation of the signature
as a structured category of algebras.

Our semantics has a ``type-theoretic'' flavor, which is inspired by the cubical
set model of Martin-LÃ¶f type theory by Bezem et al.\cite{cubical}. The core idea
is to avoid strictness issues by starting from basic ingredients which are already
strict enough. Hence, instead of modeling types as certain slices and
substitution by pullback, we model types as displayed categories with extra
structure, which naturally support strict reindexing.

We make a similar choice in the interpretation of signatures themselves: we use
structured CwFs instead of lex categories. The reason here is that CwFs allow us
to compute induction principles in strictly the same way as one would write them
down in type theory, since we have $\Ty$ and $\Tm$ for a primitive notion of
dependent objects and morphisms. In contrast, dependent objects in lex
categories is a derived notion, and the induction principles we get are only up
to isomorphism. This issue is perhaps not relevant from a purely categorical
perspective, but we are concerned with eventually implementing QIITs in proof
assistants, so we prefer if our semantics computes strictly.

In the following, we fix $i$ and $j$ levels, and define a model $M : \ToS_{i,
  1+\max(i,1+j)}$, such than $\Con_M$ is a type of structured categories (of
algebras). The level $i$ marks the level of all external sets in function
domains, and $j$ marks the level of all internal sorts in an algebra. Hence,
every algebra has level $\max(i,1+j)$. The bump is only needed for $j$, since
algebras only contain elements of $T : \Set_j$ types, while inductive sets are
themselves elements of $\Set_i$. For example, $NatAlg_i : \Set_{\max(0, 1+i)}$.

We present the components of the model in order. In the following, we use
\textbf{bold} font to disambiguate components of this model from internal
structures. For example, we use $\boldsymbol{\sigma : \Sub\,\Gamma\,\Delta}$
to denote a substitution in the model.

The model involves a large amount of technical detail, most of which we omit,
and only present the most salient parts.

\subsection{Contexts}

We define $\bCon : \Set_{1+\max(i,1+j)}$ as $\flCwF_{\max(i,1+j)}$.
%% We define
%% $\flCwF$ as follows.

\begin{definition}[Finite limit CwFs]\label{def:flCwF}
For a level $i$, there is a cETT type $\flCwF_i : \Set_{1+i}$, which is an
iterated $\Sigma$-type with the following components:
\begin{enumerate}
  \item A CwF with underlying sets all in $\Set_i$. We reuse the component
    notations from Definition \ref{def:tos}.
  \item $\Sigma$-type $\Sg : (A : \Ty\,\Gamma)\ra \Ty\,(\Gamma \ext A)
    \ra \Ty\,\Gamma$, with term formers $\proj1$, $\proj2$ and $\blank,\blank$.
  \item Identity type $\Id : (A : \Ty\,\Gamma)\ra \Tm\,\Gamma\,A\ra
    \Tm\,\Gamma\,A\ra \Ty\,\Gamma$, with $\refl$, equality reflection and UIP.
  \item Constant families. This includes a type former $\Kfam : \Con \ra
    \Ty\,\Gamma$, where $\Gamma$ is implicitly quantified, together with $\lamK
    : \Sub\,\Gamma\,\Delta \ra \Tm\,\Gamma\,(\Kfam\,\Delta)$ and its inverse
    $\appK$. The idea is that $\Kfam\,\Delta$ is a representation of $\Delta$ as
    a type in any context. Clairambault and Dybjer called constant families
    ``democracy'' in \cite{clairambault2014biequivalence}.
\end{enumerate}
\end{definition}

\begin{definition} We abbreviate the additional structure on CwFs consisting of $\Sigma$, $\Id$ and
$\Kfam$ as \emph{fl-structure}.
\end{definition}

%% We abbreviate the additional structure on CwFs consisting of $\Sigma$, $\Id$ and
%% $\Kfam$ as fl-structure. We use $\Ty$ in an flCwF to represent ``dependent
%% objects'', and $\Tm$ for ``dependent morphisms''. We use these to define
%% induction.

\begin{definition}[Notion of induction in an flCwF]
Given $\bGamma : \flCwF_i$, we have the following predicate on contexts:
\begin{alignat*}{3}
  & Inductive : \Con_{\bGamma} \ra \Set_i \\
  & Inductive\,\Gamma :\equiv (A : \Ty_{\bGamma}\,\Gamma)\ra \Tm_{\bGamma}\,\Gamma\,A
\end{alignat*}
\end{definition}

In the categorical semantics for a concrete signature, this informally means
that an algebra supports induction if for any dependent algebra over it (which
is a bundle of induction motives and methods), there is a dependent morphism
into it (which is a bundle of eliminator functions and their $\beta$-rules).

\begin{theorem}[Equivalence of initiality and induction]
An object $\Gamma : \Con_{\bGamma}$ supports induction if and only if it is
initial. Moreover, induction and initiality are both proof irrelevant
predicates.
\end{theorem}
\begin{proof} By brief internal flCwF reasoning in \cite{kaposi2019constructing}.
\end{proof}

The reason for the ``finite limit CwF'' naming is the following: Clairambault
and Dybjer showed that the 2-category of flCwFs is biequivalent to the
2-category of finitely complete categories
\cite{clairambault2014biequivalence}. In particular, in an flCwF the categorical
product of $\Gamma$ and $\Delta$ can be given as $\Gamma \ext \Kfam\, \Delta$,
and the equalizer of $\sigma$ and $\delta$ as $\Gamma\ext
\Id\,(\K\,\Delta)\,(\lamK\,\sigma)\,(\lamK\,\delta)$.

\todo{segue text?}

\begin{definition} A \emph{context isomorphism} is an invertible morphism $\sigma : \Sub\,\Gamma\,\Delta$. We note the inverse as $\sigma^{-1}$. We also use the notation $\sigma : \Gamma \simeq \Delta$.
\end{definition}

\begin{definition}[Type categories, c.f.\ \cite{clairambault2014biequivalence}]\label{def:type_categories} For each $\Gamma : \Con$, there is a category
whose objects are types $A : \Ty\,\Gamma$, and morphisms from $A$ to $B$ are
terms $t : \Tm\,(\Gamma\,\ext\,A)\,B[\p]$. Identity morphisms are given by $\q :
\Tm\,(\Gamma\,\ext\,A)\,A[\p]$, and composition $t \circ u$ by $t[\p, u]$. The
assignment of type categories to contexts extends to a split indexed category. For
each $\sigma : \Sub\,\Gamma\,\Delta$, there is a functor from $\Ty\,\Delta$ to
$\Ty\,\Gamma$, which sends $A$ to $A[\sigma]$ and $t :
\Tm\,(\Gamma\,\ext\,A)\,B[\p]$ to $t[\sigma\circ \p, \q]$.
\end{definition}

\begin{definition} A \emph{type isomorphism}, notated $t : A \simeq B$ is an isomorphism in a type category. We note the inverse as $t^{-1}$.
\end{definition}

\subsection{Substitutions}

\todo{we have a level lift here, decide how to handle}

%% We define $\boldsymbol{\Sub\,\Gamma\,\Delta} : \Set_{1 + \max(i, j+1)}$ as the type
%% of weak flCwF morphisms from $\boldsymbol{\Gamma}$ to $\boldsymbol{\Delta}$.

\begin{definition}\label{def:weakmorphism} A \emph{weak flCwF morphism} $\boldsymbol{\sigma : \Sub\,\Gamma\,\Delta}$ is a functor between underlying categories, which additionally maps types to types and terms to terms, and satisfies the following:
  \begin{enumerate}
    \item $\bsigma\,(A[\sigma]) = (\bsigma\,A)\,[\bsigma\,\sigma]$
    \item $\bsigma\,(t[\sigma]) = (\bsigma\,t)\,[\bsigma\,\sigma]$
    \item The unique map $\epsilon : \Sub\,(\bsigma\,\emptycon)\,\emptycon$ has a retraction.
    \item Each $(\bsigma\,\p,\,\bsigma\,\q) : \Sub\,(\bsigma\,(\Gamma\,\ext\,A))\,(\bsigma\,\Gamma\,\ext\,\bsigma\,A)$ has an inverse.
  \end{enumerate}
\end{definition}

In short, $\bsigma$ preserves substitution strictly and preserves
empty context and context extension up to isomorphism. We notate the evident
isomorphisms as $\bsigma_{\emptycon} :
\bsigma\,\emptycon \simeq \emptycon$ and $\bsigma_{\ext}
:
\bsigma\,(\Gamma\,\ext\,A)\,\simeq\,\bsigma\,\Gamma\,\ext\,\bsigma\,A$. Our notion of weak morphism is the same as in \cite{birkedal2018modal}, when restricted to CwFs.

\begin{theorem}\label{thm:flpres} Every $\boldsymbol{\sigma : \Sub\,\Gamma\,\Delta}$ preserves fl-structure up to type isomorphism. That is, we have
\begin{alignat*}{3}
  & \bsigma_{\Sigma} : \bsigma\,(\Sigma\,A\,B) \simeq \Sigma\,(\bsigma\,A)\,((\bsigma\,B)[\bsigma_{\ext}^{-1}]) \\
  & \bsigma_{\K} : \bsigma\,(\K\,\Delta) \simeq \K\,(\bsigma\,\Delta) \\
  & \bsigma_{\Id} : \bsigma\,(\Id\,t\,u) \simeq \Id\,(\bsigma\,t)\,(\bsigma\,u)
\end{alignat*}
These are all natural in the following sense: for $\sigma :
\Sub_{\bGamma}\,\Gamma\,\Delta$, the functorial action of $\bsigma\,\sigma :
\Sub_{\bDelta}\,(\bsigma\,\Gamma)\,(\bsigma\,\Delta)$ on $\bsigma_{\Sigma}$ (in
the $\bsigma\,\Gamma$ context) is equal to $\bsigma_{\Sigma}$ (in
$\bsigma\,\Delta$), and similarly for $\bsigma_{\K}$ and $\bsigma_{\Id}$.

Moreover, $\bsigma$ preserves all term and substitution formers in the
fl-structure. For example, $\bsigma\,(\proj1\,t) = \proj1\,
(\bsigma_{\Sigma}[\id, \bsigma\,t])$.
\end{theorem}
\begin{proof}
For $\bsigma_{\Sigma}$, we construct the following context isomorphism:
\begin{alignat*}{3}
& (\bsigma\,\Gamma\,\ext\,\bsigma\,(\Sigma\,A\,B)) \simeq
  (\bsigma\,\Gamma\,\ext\,\bsigma\,A\,\ext\,(\Sigma\,B)[\bsigma_{\ext}^{-1}]) \\
& \simeq (\bsigma\,\Gamma\,\ext\,\Sigma\,(\bsigma\,A)\,((\Sigma\,B)[\bsigma_{\ext}^{-1}]))
\end{alignat*}
This isomorphism is the identity on $\bsigma\,\Gamma$, hence we can extract the
desired $\bsigma_{\Sigma} : \bsigma\,\Sigma\,A\,B) \simeq
\Sigma\,(\bsigma\,A)\,((\bsigma\,B)[\bsigma_{\ext}^{-1}])$ from it.

For $\bsigma_{\K}$, note the following:
\begin{alignat*}{3}
  & (\emptycon\,\ext\,\bsigma\,(\K\,\Delta)) \simeq
    (\bsigma\,\emptycon\,\ext\,\bsigma\,(\K\,\Delta)) \simeq
    \bsigma\,(\emptycon\,\ext\,\K\,\Delta)\\
  & \simeq \bsigma\,\Delta \simeq (\emptycon\,\ext\,K\,(\bsigma\,\Delta))
\end{alignat*}
This yields a type isomorphism $\bsigma\,(\K\,\Delta)) \simeq
\K\,(\bsigma\,\Delta)$ in the empty context, and we use the functorial action of
$\epsilon : \Sub\,\Gamma\,\emptycon$ to weaken it to any $\Gamma$ context.

For $\bsigma_{\Id}$, both component morphisms can be constructed by $\refl$ and
equality reflection, and the morphisms are inverses by UIP. We omit here the
verification of naturality and that $\bsigma$ preserves term and substitution
formers in the fl-structure.
\end{proof}

\subsection{Identity and Composition}

$\bid : \bSub\,\bGamma\,\bGamma$ is defined in the obvious way, with identities for
underlying functions and for preservation morphisms.

For $\boldsymbol{\sigma \circ \delta}$, the underlying functions are given by
function composition, and the preservation morphisms are given as follows:
\begin{alignat*}{3}
  & (\boldsymbol{\sigma \circ \delta})_{\emptycon}^{-1} :\equiv
    \bsigma\,\bdelta_{\emptycon}^{-1} \circ \bdelta_{\emptycon}^{-1} \\
  & (\boldsymbol{\sigma \circ \delta})_{\ext}^{-1} :\equiv
    \bsigma\,\bdelta_{\ext}^{-1} \circ \bdelta_{\ext}^{-1}
\end{alignat*}

It is easy to verify the left and right identity laws and associativity for $\boldsymbol{\blank\circ\blank}$.

\begin{lemma}\label{lem:idcomppres} The derived preservation isomorphisms for the fl-structure can be decomposed analogously; all derived isomorphisms in $\bid$ are identities, and we have
\begin{alignat*}{3}
  & (\boldsymbol{\sigma \circ \delta})_{\Sigma} =
  \bsigma\,\bdelta_{\Sigma} \circ \bdelta_{\Sigma}\\
  & (\boldsymbol{\sigma \circ \delta})_{\K} =
  \bsigma\,\bdelta_{\K} \circ \bdelta_{\K}\\
  & (\boldsymbol{\sigma \circ \delta})_{\Id} =
  \bsigma\,\bdelta_{\Id} \circ \bdelta_{\Id}
\end{alignat*}
On the right sides, $\blank\circ\blank$ refers to composition of type morphisms.
\end{lemma}
\begin{proof} In the case of $\Id$, the equations hold immediately by UIP. For $\Sigma$ and $\K$, we prove by flCwF computation and straightforward unfolding of definitions.
\end{proof}

\subsection{Empty Context}
The empty context $\boldsymbol{\emptycon : \Con}$ is the terminal flCwF, which
has all underlying sets defined as $\top$ (or constantly $\top$), with an
evident unique $\boldsymbol{\epsilon : \Sub\,\Gamma\,\emptycon}$. Since
$\bepsilon$ is a strict flCwF morphism, $\bepsilon_{\emptycon}^{-1}$ and
$\bepsilon_{\ext}^{-1}$ are both identity morphisms.

\subsection{Types}

We define $\boldsymbol{\Ty\,\Gamma} : \Set_{1 + \max(i, j+1)}$ as the type of
split flCwF-isofibrations over $\bGamma$. We extend Ahrens' and Lumsdaine's
displayed categories and their definition of isofibrations \cite{displayedcats}.
We first define displayed flCwFs, then specify iso-cleaving as additional structure
on top of that.

\begin{definition}[Displayed flCwF] The type of displayed flCwFs at level $i$ is given as the logical predicate interpretation \cite{TODO} of $\flCwF_i$. For each flCwF component in $\bGamma$, there is a component in a displayed flCwF which ``lies over'' it.

In situations where we need to refer to both ``base'' and displayed things, we give
\ul{underlined} names to contexts, substitutions, types and terms in a base
flCwF. For example, we may have $\ulGamma : \Con_{\bGamma}$ living in
$\boldsymbol{\Gamma : \Con}$, and $\Gamma : \Con_{\bA}\,\ulGamma$ living in
$\boldsymbol{A : \Ty\,\Gamma}$. We only use underlining on cETT variable names,
and overload flCwF component names for displayed counterparts.

Concretely, a displayed flCwF $\bA$ over $\bGamma$ has the following underlying sets, which we call displayed contexts, substitutions, types and terms respectively.
\begin{alignat*}{3}
  & \Con_{\bA} && : \Con_{\bGamma}\ra \Set_i\\
  & \Sub_{\bA} && : \Con_{\bA}\,\ulGamma \ra \Con_{\bA}\,\ulDelta \ra \Sub_{\bGamma}\,\ulGamma\,\ulDelta \ra \Set_i \\
  & \Ty_{\bA}  && : \Con_{\bA}\,\ulGamma \ra \Ty_{\bGamma}\,\ulGamma \ra \Set_i\\
  & \Tm_{\bA}  && : (\Gamma : \Con_{\bA}\,\ulGamma)\ra \Ty_{\bA}\,\Gamma\,\ulA \ra \Tm_{\bGamma}\,\ulGamma\,\ulA \ra \Set_i
\end{alignat*}

Above, we implicitly quantify over $\ulGamma$, $\ulDelta$ and $\ulA$ base
parameters. We also have the following components for empty context, context
extension and substitution. We omit listing other components here.
\begin{alignat*}{3}
  & \emptycon_{\bA} && : \Con_{\bA}\,\emptycon_{\bGamma}\\
  & \ext_{\bA}      && : (\Gamma : \Con_{\bA}\,\ulGamma)\ra \Ty_{\bA}\,\Gamma\,\ulA \ra
                     \Con_{\bA}\,\Gamma\,(\ulGamma \ext_{\bGamma} \ulA)\\
  & \blank[\blank]_{\bA} && : \Ty_{\bA}\,\Delta\,\ulA \ra \Sub_{\bA}\,\Gamma\,\Delta\,\ulsigma
                     \ra \Ty_{\bA}\,\Gamma\, (\ulA[\ulsigma]_{\bGamma})\\
  & \blank[\blank]_{\bA} && : \Tm_{\bA}\,\Delta\,A\,\ult \ra (\sigma : \Sub_{\bA}\,\Gamma\,\Delta\,\ulsigma)\\
  & && \hspace{0.5em}\ra \Tm_{\bA}\,\Gamma\, (A[\sigma]_{\bA})\,(\ult[\ulsigma]_{\bGamma})
\end{alignat*}
\end{definition}

In the following we will often omit $_{\bGamma}$ and $_{\bA}$ subscripts on
components; for example, in the type $\Con_{\bA}\,\emptycon$, the $\emptycon$ is clearly
a base component in $\bGamma$.

We also need displayed counterparts to the previously defined derived notions on flCwFs;
these are again given as logical predicate interpretations of the non-displayed definitions.

\begin{definition}[Displayed type categories] For each $\Gamma : \Con_{\bA}\,\ulGamma$, there
is a displayed category over the type category $\Ty_{\bGamma}\,\ulGamma$, whose objects
over $\ulA : \Ty_{\bGamma}\,\ulGamma$ are elements of $\Ty_{\bA}\,\Gamma\,\ulA$, and displayed morphisms over $\ult : \Tm_{\bGamma}\,(\ulGamma \ext \ulA)\,(\ulB[\p])$ are elements of $\Tm_{\bA}\,(\Gamma \ext A)\,(B[\p])\,\ult$. The identity morphism is given by $\q_{\bA}$, and the composition of $t$ and $u$ is $t[\p_{\bA},u]$. Analogously to Definition \ref{def:type_categories}, this extends to a displayed split indexed category.
\end{definition}

\begin{definition}[Displayed isomorphisms] A \emph{displayed context isomorphism} over $\ulsigma : \ulGamma \simeq \ulDelta$, notated $\sigma : \Gamma \simeq_{\ulsigma} \Delta$, is an invertible displayed morphism $\sigma : \Sub_{\bA}\,\Gamma\,\Delta\,\ulsigma$, with inverse $\sigma^{-1} : \Sub_{\bA}\,\Delta\,\Gamma\,\ulsigma^{-1}$. A \emph{displayed type isomorphism} over $\ult : \ulA \simeq \ulB$, notated $t : A \simeq_{\ult} B$, is an isomorphism in a displayed type category.
\end{definition}

\begin{definition} A \emph{vertical morphism} lies over an identity morphism. We use this definition for context morphisms (substitutions) and type morphisms as well.
\end{definition}

In contrast to \cite{kaposi2019constructing}, it is not sufficient to model
types with displayed flCwFs. In ibid.\ substitutions are modeled as strict
morphisms, which we cannot do because our infinitary function types and identity
types cannot be interpreted strictly, as we will see in Section
\ref{TODO}. Strict preservation is expressed with metatheoretic equality, which
is respected by all cETT constructions, but isomorphisms are not necessarily
respected. Hence, we need to add additional structure to displayed flCwFs which
expresses preservation of base isomorphisms.

\begin{definition}[Context iso-cleaving] This lifts a base context isomorphism to a displayed one. It consists of
\begin{alignat*}{3}
  & \coe &&: \ulGamma \simeq \ulDelta \ra \Con_{\bA}\,\ulGamma \ra \Con_{\bA}\,\ulDelta\\
  & \coh &&: (\ulsigma : \ulGamma \simeq \ulDelta)(\Gamma : \Con_{\bA}\,\ulGamma)
           \ra \Gamma \simeq_{\ulsigma} \coe\,\ulsigma\,\Gamma\\
  & \coe^{\id} && : \coe\,\id\,\Gamma = \Gamma\\
  & \coe^{\circ} && : \coe\,(\ulsigma\circ\uldelta)\,\Gamma = \coe\,\ulsigma\,(\coe\,\uldelta\,\Gamma)\\
  & \coh^{\id} && : \coh\,\id\,\Gamma = \id\\
  & \coh^{\circ} && : \coh\,(\ulsigma\circ\uldelta)\,\Gamma = \coh\,\ulsigma\,(\coe\,\uldelta\,\Gamma)
          \circ \coh\,\uldelta\,\Gamma
\end{alignat*}
Here, $\coe$ and $\coh$ abbreviate ``coercion'' and ``coherence'' respectively.
\end{definition}

\begin{definition}[Type iso-cleaving] This consists of
\begin{alignat*}{3}
  & \coe &&: \ulA \simeq \ulB \ra \Ty_{\bA}\,\Gamma\,\ulA \ra \Ty_{\bA}\,\Gamma\,\ulB\\
  & \coh &&: (\ult : \ulA \simeq \ulB)(A : \Ty_{\bA}\,\Gamma\,\ulA)
           \ra A \simeq_{\ult} \coe\,\ult\,A\\
  & \coe^{\id} && : \coe\,\id\,A = A\\
  & \coe^{\circ} && : \coe\,\ult\,(\coe\,\uldelta\,A) = \coe\,(\ult\circ\uldelta)\,A\\
  & \coh^{\id} &&: \coh\,\id\,A = \id\\
  & \coh^{\circ} &&: \coh\,(\ult\circ\uldelta)\,A = \coh\,\ult\,(\coe\,\uldelta\,A)
          \circ \coh\,\uldelta\,A
\end{alignat*}
Additionally, for $\sigma : \Sub_{\bA}\,\Gamma\,\Delta\,\ulsigma$, we have
\begin{alignat*}{3}
  & \coe[] &&: \coe\,(\ult[\ulsigma])\,(A[\sigma]) = (\coe\,\ult\,A)[\sigma]\\
  & \coh[] &&: \coh\,(\ult[\ulsigma\circ \p,\q])\,(A[\sigma]) = (\coh\,\ult\,A)[\sigma]
\end{alignat*}

\end{definition}

\begin{definition} A \emph{split flCwF isofibration} is a displayed flCwF equipped with iso-cleaving for contexts and types.
\end{definition}

\emph{Remark.} It is not possible to model types as fibrations or opfibrations, because
we have no restriction on the variance of ToS types. For example, the type which extends
a pointed set to a $Nat$-signature is invariant in the base signature.

\subsection{Type Substitution}
We aim to define $\boldsymbol{\blank[\blank] : \Ty\,\Delta \ra
  \Sub\,\Gamma\,\Delta \ra \Ty\,\Gamma}$, such that $\boldsymbol{A[\id]} = \bA$
and $\boldsymbol{A[\sigma\circ\delta]} = \boldsymbol{A[\sigma][\delta]}$. The
underlying sets are given by simple composition:
\begin{alignat*}{3}
  & \Con_{\boldsymbol{A[\sigma]}}\,\ulGamma && :\equiv \Con_{\bA}\,(\bsigma\,\ulGamma)\\
  & \Sub_{\boldsymbol{A[\sigma]}}\,\Gamma\,\Delta\,\ulsigma && :\equiv
    \Sub_{\bA}\,\Gamma\,\Delta\,(\bsigma\,\ulsigma)\\
  & \Ty_{\boldsymbol{A[\sigma]}}\,\Gamma\,\ulA && :\equiv
      \Ty_{\bA}\,\Gamma\,(\bsigma\,\ulA)\\
  & \Tm_{\boldsymbol{A[\sigma]}}\,\Gamma\,A\,\ult && :\equiv
      \Tm_{\bA}\,\Gamma\,A\,(\bsigma\,\ult)
\end{alignat*}

Moreover, $\id_{\boldsymbol{A[\sigma]}} :\equiv \id_{\bA}$,
$\sigma\circ_{\boldsymbol{A[\sigma]}}\delta :\equiv \sigma\circ_{\bA}\delta$,
and likewise substitution components are given by corresponding substitution
components in $\bA$.

Context and type formers are given by coercing $\bA$
structures along $\bsigma$ preservation isomorphisms. For example:
\begin{alignat*}{3}
  &\emptycon_{\boldsymbol{A[\sigma]}} && :\equiv
    \coe\,\bsigma_{\emptycon}^{-1}\,\emptycon_{\bA}\\
  &\Gamma\ext_{\boldsymbol{A[\sigma]}}A && :\equiv
    \coe\,\bsigma_{\ext}^{-1}\,(\Gamma\ext_{\bA} A)\\
  &\Id_{\boldsymbol{A[\sigma]}}\,t\,u && :\equiv
    \coe\,\bsigma_{\Id}^{-1}\,(\Id_{\bA}\,t\,u)
\end{alignat*}

Term and substitution formers are given by composing $\coh$-lifted
isomorphisms with term and substitution formers from $\bA$. For example:
\begin{alignat*}{3}
  & \epsilon_{\boldsymbol{A[\sigma]}} && :\equiv
    \coh\,\bsigma_{\emptycon}^{-1}\,\emptycon_{\bA} \circ \epsilon_{\bA}\\
  & \p_{\boldsymbol{A[\sigma]}} && :\equiv
    \p_{\bA} \circ (\coh\,\bsigma_{\ext}^{-1}\,(\Gamma\ext A))^{-1}\\
  & \appK_{\boldsymbol{A[\sigma]}}\,t && :\equiv
    \appK_{\bA}\,((\coh\,\bsigma_{\K}\,(\K\,\Delta))^{-1}\circ t)
\end{alignat*}
Equations for term and type substitution follow from naturality of preservation
isomorphisms in $\bsigma$, $\coe[]$, $\coh[]$ and substitution equations in
$\bA$.

\todo{iso-cleaving}

Functoriality of type substitution, i.e.\ $\boldsymbol{A[\id]} = \bA$ and
$\boldsymbol{A[\sigma\circ\delta]} = \boldsymbol{A[\sigma][\delta]}$, follows
from Lemma \ref{lem:idcomppres} and split cleaving given by $\coe_{\id}$,
$\coe_{\circ}$, $\coh_{\id}$ and $\coh_{\circ}$ in $\bA$.

\subsection{Terms}

$\boldsymbol{\Tm\,\Gamma\,A} : \Set_{1 + \max(i, 1+j)}$ is defined as the type of
\emph{weak flCwF sections} of $\bA$. The underlying functions of $\bt :
\bTm\,\bGamma\,\bA$ are as follows:
\begin{alignat*}{3}
  & \bt : (\ulGamma : \Con_{\bGamma}) \ra \Con_{\bA}\,\ulGamma\\
  & \bt : (\ulsigma : \Sub_{\bGamma}\,\ulGamma\,\ulDelta)
         \ra \Sub_{\bA}\,(\bt\,\ulGamma)\,(\bt\,\ulDelta)\,\ulsigma\\
  & \bt : (\ulA : \Ty_{\bGamma}) \ra \Ty_{\bA}\,(\bt\,\ulGamma)\,\ulA\\
  & \bt : (\ult : \Tm_{\bGamma}\,\ulGamma\,\ulA) \ra
          \Tm_{\bA}\,(\bt\,\ulGamma)\,(\bt\,\ulA)\,\ult
\end{alignat*}
Such that
\begin{enumerate}
  \item $\bt\,(\ulA[\ulsigma]) = (\bt\,\ulA)\,[\bt\,\ulsigma]$
  \item $\bt\,(\ult[\ulsigma]) = (\bt\,\ult)\,[\bt\,\ulsigma]$
  \item The unique map $\epsilon_{\bA} : \Sub\,(\bt\,\emptycon)\,\emptycon\,\id$ has a vertical retraction.
  \item Each $(\bt\,\p,\,\bt\,\q) : \Sub\,(\bt\,(\ulGamma\,\ext\,\ulA))\,(\bt\,\ulGamma\,\ext\,\bt\,\ulA)\,\id$ has a vertical inverse.
\end{enumerate}

Similarly to Definition \ref{def:weakmorphism}, we denote the evident preservation
isomorphisms as $\bt_{\emptycon} : \bt\,\emptycon \simeq_{\id} \emptycon$ and
$\bt_{\ext} : \bt\,(\ulGamma\ext \ulA) \simeq_{\id} \bt\,\ulGamma \ext
\bt\,\ulA$. In short, weak section is a dependently typed analogue of weak
morphism, with dependent underlying functions and displayed preservation
isomorphisms. We also have the derived fl-preservation isomorphisms.

\begin{theorem} A weak section $\boldsymbol{t : \Tm\,\Gamma\,A}$ preserves fl-structure up to vertical type isomorphisms, that is, the following are derivable:
\begin{alignat*}{3}
  & \bt_{\Sigma} : \bt\,(\Sigma\,\ulA\,\ulB) \simeq_{\id} \Sigma\,(\bt\,\ulA)\,((\bt\,\ulB)[\bt_{\ext}^{-1}]) \\
  & \bt_{\K} : \bt\,(\K\,\ulDelta) \simeq_{\id} \K\,(\bt\,\ulDelta) \\
  & \bt_{\Id} : \bt\,(\Id\,\ult\,\ulu) \simeq_{\id} \Id\,(\bt\,\ult)\,(\bt\,\ulu)
\end{alignat*}
Also, the above isomorphisms are natural in the sense of Theorem
\ref{thm:flpres}, and $\bt$ preserves type and substitution formers in the
fl-structure.
\end{theorem}
\begin{proof} The construction of isomorphisms is the same as in Theorem \ref{thm:flpres}. Indeed, every construction there has a displayed counterpart which we can use here.
\end{proof}

We note though that the move from Theorem \ref{thm:flpres} to here is not simply a
logical predicate translation, because we are only lifting the codomain of a
weak morphism to a displayed version, and we leave the domain non-displayed. We
leave to future work the investigation of such asymmetrical (or
``modal'') logical predicate translations.

\subsection{Term Substitution}

$\boldsymbol{\blank[\blank] : \Tm\,\Delta\,A \ra (\sigma : \Sub\,\Gamma\,\Delta)
  \ra \Tm\,\Gamma\,(A[\sigma])}$ is given similarly to
$\boldsymbol{\blank\circ\blank}$ in Section \ref{TODO}. Underlying functions
are given by function composition, and preservation morphisms are also similar:
\begin{alignat*}{3}
  & (\boldsymbol{t[\sigma]})_{\emptycon}^{-1} :\equiv
    \bt\,\bsigma_{\emptycon}^{-1} \circ \bt_{\emptycon}^{-1} \\
  & (\boldsymbol{t[\sigma]})_{\ext}^{-1} :\equiv
    \bt\,\bsigma_{\ext}^{-1} \circ \bt_{\ext}^{-1}
\end{alignat*}

We also have the same decomposition of derived isomorphisms as in Lemma
\ref{lem:idcomppres}. We do not have to show functoriality of term substitution
here, since that is derivable in any CwF \cite{TODO}.

\subsection{Context Extension and Comprehension}

$\boldsymbol{\Gamma \ext A : \Con}$ is defined as the \emph{total flCwF} of
$\bA$. This is given by bundling together all displayed flCwF components in
$\bA$ with corresponding base components in $\bGamma$, using the metatheoretic
$\Sigma$-type. It is a straightforward extension of total categories in
\cite{displayedcats}.

$\boldsymbol{\p : \Sub\,(\Gamma\ext A)\,\Gamma}$ is a strict morphism given by
taking a first projection for each component. $\boldsymbol{\q : \Tm\,(\Gamma\ext
  A)\,(A[\p])}$ is likewise a strict flCwF section given by second projections. Substitution extension $\boldsymbol{\sigma,\,t}$ is given by pointwise combining $\bsigma$ and $\bt$ with metatheoretic $\Sigma$ pairing, e.g.\ $\Con_{\boldsymbol{(\sigma,t)}}\,\ulGamma :\equiv (\bsigma\,\ulGamma,\,\bt\,\ulGamma)$.

\subsection{Universe}

\begin{definition} For a level $i$, we write $\bSet_i$ for the flCwF of sets where $\Con_{\bSet_i} :\equiv \Set_i$ and $\Sub_{\bSet_i}\,\Gamma\,\Delta :\equiv \Gamma \ra \Delta$.
\end{definition}

We define $\boldsymbol{\U : \Ty\,\Gamma}$ as the isofibration which is
constantly $\bSet_j$. A constant isofibration does not actually depend on
the base flCwF, and has trivial iso-cleaving where $\coe$-s are identity
functions. Hence, we have $\Con_{\bU}\,\ulGamma :\equiv \Set_j$ and $\Sub_{\bU}\,\Gamma\,\Delta\,\ulsigma :\equiv \Gamma \ra \Delta$.

\emph{Remark.} The type $\bTm\,\bGamma\,\bU$ is strictly equal to $\bSub\,\bGamma\,\bSet_j$, so in the following we will think about semantic elements of the universe as weak morphisms from $\bGamma$ to $\bSet_j$.

\subsection{Elements of the Universe}

We define $\boldsymbol{\El : \Tm\,\Gamma\,\U \ra \Ty\,\Gamma}$ as discrete
isofibration formation. For $\boldsymbol{a : \Tm\,\Gamma\,\U}$, the underlying
sets of $\bEl\,\ba$ are the following:
\begin{alignat*}{3}
  & \Con_{\bEl\,\ba}\,\ulGamma && :\equiv \ba\,\ulGamma\\
  & \Sub_{\bEl\,\ba}\,\Gamma\,\Delta\,\ulsigma && :\equiv \ba\,\ulsigma\,\Gamma = \Delta\\
  & \Ty_{\bEl\,\ba}\,\Gamma\,\ulA && :\equiv \ba\,\ulA\,\Gamma\\
  & \Tm_{\bEl\,\ba}\,\Gamma\,A\,\ult && :\equiv \ba\,\ult\,\Gamma = A
\end{alignat*}
Hence, in $\bEl\,\ba$, $\Sub$ and $\Tm$ are propositional. We use the
isomorphisms $\ba_{\emptycon} : \ba\,\emptycon \simeq \top$ and $\ba_{\ext} :
\ba\,(\ulGamma\ext\ulA) \simeq (\Gamma :
\ba\,\ulGamma)\times(\ba\,\ulA\,\Gamma)$ to define empty context and context
extension:
\begin{alignat*}{3}
  & \emptycon_{\bEl\,\ba} && :\equiv \ba_{\emptycon}^{-1}\,\tt\\
  & (\Gamma\ext_{\bEl\,\ba} A) && :\equiv \ba_{\ext}^{-1}\,(\Gamma,\,A)
\end{alignat*}
We likewise use preservation isomorphisms to define $\K$, $\Id$ and $\Sigma$.
Context coercion is $\coe\,\ulsigma\,\Gamma :\equiv \ba\,\ulsigma\,\Gamma$. Type coercion, for $A : \ba\,\ulA\,\Gamma$ is given as $\coe\,\ult\,A :\equiv \ba\,\ult\,(\ba_{\ext}^{-1}\,(\Gamma,\,A))$.

\subsection{Inductive Function Space}

For $\boldsymbol{a : \Tm\,\Gamma\,\U}$ and $\boldsymbol{B :
  \Ty\,(\Gamma\ext\El\,a)}$, we aim to define $\boldsymbol{\Pi\,a\,B}
\boldsymbol{:} \bTy\,\bGamma$. We define this as a dependent product of
isofibrations, indexed by a discrete domain. With a general $\bA \boldsymbol{:}
\bTy\,\bGamma$ domain, $\bPii$ would not be definable, since variance issues
preclude $\Pi$-types in the CwF of categories \cite{TODO}.

%% _{(\bPii\,\ba\,\bB)}

Contexts are products of $\bB$-contexts, and types are products of $\bB$-types,
indexed respectively by contexts and types of $\bEl\,\ba$.
\begin{alignat*}{3}
  & \Con_{(\bPii\,\ba\,\bB)}\,\ulGamma &&:\equiv (\gamma : \ba\,\ulGamma)\ra \Con_{\bB}\,(\ulGamma, \gamma)\\
  & \Ty_{(\bPii\,\ba\,\bB)}\,\Gamma\,\ulA &&:\equiv (\gamma : \ba\,\ulGamma)(a : \ba\,\ulA\,\gamma)\ra \Ty_{\bB}\,(\Gamma\,\gamma)\,(\ulA, a)
\end{alignat*}
Note that since $\bB$ is over the total $\boldsymbol{(\Gamma\ext\El\,a)}$,
$\Con_{\bB}$ has a $\Sigma$-typed argument, and likewise the last argument
of every $\bB$ component.  We could define substitutions similarly, as
products of substitutions:
\begin{alignat*}{3}
  & \Sub_{(\bPii\,\ba\,\bB)}\,\Gamma\,\Delta\,\ulsigma :\equiv
  (\gamma : \ba\,\ulGamma)(\delta : \ba\,\ulDelta)
  (\sigma : \Sub_{(\bEl\,\ba)}\,\gamma\,\delta\,\ulsigma)\\
  &\hspace{6.5em}\ra \Sub_{\bB}\,(\Gamma\,\gamma)\,(\Delta\,\delta)\,(\ulsigma, \sigma)
\end{alignat*}
This would work, but we know that $\Sub_{(\bEl\,\ba)}\,\gamma\,\delta\,\ulsigma$ is defined
as $\ba\,\ulsigma\,\gamma = \delta$, so we can eliminate $\sigma$ by singleton contraction,
and use the following equivalent definition:
\begin{alignat*}{3}
  & \Sub_{(\bPii\,\ba\,\bB)}\,\Gamma\,\Delta\,\ulsigma :\equiv
  (\gamma : \ba\,\ulGamma)\ra\Sub_{\bB}\,(\Gamma\,\gamma)\,(\Delta\,(\ba\,\ulsigma\,\gamma)\,(\ulsigma, \refl)
\end{alignat*}
The benefit of the contracted definition is that it computes preservation laws
in algebra homomorphisms strictly as expected, while the non-contracted
definition computes homomorphisms as functional logical relations.

Terms are also given as a singleton-contracted version of products of terms. In
$\bPii\,\ba\,\bB$, all other structure is given pointwise by $\bB$-structure.

Iso-cleaving is given by transporting indices backwards in $\bEl\,\ba$ and outputs forwards
in $\bB$:
\begin{alignat*}{3}
  & \coe\,\ulsigma\,\Gamma &&:\equiv
    \lambda\,\gamma.\,\coe_{\bB}\,(\ulsigma,\refl)\,(\Gamma\,(\ba\,(\ulsigma^{-1})\,\gamma))\\
  & \coe\,\ult\,A &&:\equiv
    \lambda\,\gamma\,a.\,\coe_{\bB}\,(\ult,\refl)\,(A\,(\ba\,(\ult^{-1})\,(\ba_{\ext}^{-1}(\gamma,a))))
\end{alignat*}
Likewise, $\coh$-s are given by backwards-forwards $\coh$-s.

\subsection{External Function Space}

For $A : \Set_i$ and $\bB : A \ra \bTy\,\bGamma$, we define $\bPie\,A\,\bB \boldsymbol{:} \bTy\,\bGamma$ as
the evident $A$-indexed direct product of $\bB$.

\subsection{Infinitary Function Space}

For $A : \Set_i$ and $\bb : A \ra \bTm\,\bGamma\,\bU$, we aim to define
$\bPiinf\,A\,\bB \boldsymbol{:} \bTm\,\bGamma\,\bU$.



%% Acknowledgments
\begin{acks}
This work was supported by the European Union, co-financed by the
European Social Fund (EFOP-3.6.3-VEKOP-16-2017-00002) and COST Action
EUTypes CA15123.
\end{acks}


%% Bibliography
\bibliography{references}

\end{document}
