
\documentclass{llncs}

\usepackage[utf8]{inputenc}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathpartir}
\usepackage{scalerel}

%% Definition env with non-italic body text
\spnewtheorem{nidefinition}[definition]{Definition}{\bfseries}{\textnormal}

%% abbrevs
%% ------------------------------------------------------------

\input{abbrevs.tex}
\newcommand{\Lift}{\Uparrow}
\newcommand{\ToS}{\mathsf{ToS}}
\newcommand{\ext}{\triangleright}
\newcommand{\emptycon}{\scaleobj{.75}\bullet}
\newcommand{\Pii}{\mathsf{\Pi}}
\newcommand{\appi}{\mathsf{app}}
\newcommand{\lami}{\mathsf{lam}}
\newcommand{\Pie}{\mathsf{\hat{\Pi}}}
\newcommand{\appe}{\mathsf{ap\hat{p}}}
\newcommand{\lame}{\mathsf{la\hat{m}}}
\newcommand{\Piinf}{\mathsf{\tilde{\Pi}}}
\newcommand{\appinf}{\mathsf{ap\tilde{p}}}
\newcommand{\laminf}{\mathsf{la\tilde{m}}}

\newcommand{\appitt}{\mathop{{\scriptstyle @}}}

\newcommand{\Refl}{\mathsf{Refl}}

\newcommand{\IdU}{\mathsf{IdU}}
\newcommand{\ReflU}{\mathsf{ReflU}}
\newcommand{\Sig}{\mathsf{Sig}}

\newcommand{\Sg}{\mathsf{\Sigma}}
\newcommand{\flCwF}{\mathsf{flCwF}}
\newcommand{\Kfam}{\mathsf{K}}



%% ------------------------------------------------------------


\begin{document}

\title{Generalizations of Quotient Inductive-Inductive Types\thanks{This work
    was supported by EFOP-3.6.3-VEKOP-16-2017-00002 grant and COST
    Action EUTypes CA15123.}}

\author{Ambrus Kaposi \and Andr{\'a}s Kov{\'a}cs}
\institute{E{\"o}tv{\"o}s Lor{\'a}nd University, Budapest, Hungary \\ \{akaposi$|$kovacsandras\}@inf.elte.hu}

\maketitle

\begin{abstract}
Quotient inductive-inductive types (QIITs) are generalized inductive types which
allow sorts to be indexed over previously declared sorts, and allow usage of
equality constructors. QIITs are especially useful for algebraic descriptions of
type theories and constructive definitions of real, ordinal and surreal
numbers. We develop new metatheory for large QIITs, large elimination, recursive
equations, infinitary constructors and equations between sorts.
%% First, we develop tools which allow precise and convenient handling
%% of universe levels, working internally in an extensional type theory with
%% cumulative universes.
As in prior work, we describe QIITs using a type theory where each context
represents a QIIT signature. However, in our case the theory of signatures can
also describe its own signature. We use self-description to bootstrap a model
theory for the theory of signatures without using preterms or assuming a
pre-existing internal syntax for a type theory. We give initial algebra
semantics for described QIITs, and we show the equivalence of initiality and
induction. We present two extensions of a previous term model construction. The
first one constructs all large infinitary QIITs without sort equations from the
QIIT of the theory of signatures. The second one constructs all large finitary
QIITs with sort equations, from the same syntax. This separation is required
because handling infinitary constructors in the term model requires showing a
strong form of invariance under algebra isomorphisms, which is violated by sort
equations.

\end{abstract}

\section{Introduction}
\label{sec:intro}

\todo[inline]{Citations}

The aim of this work is to provide theoretical underpinning to a general notion
of inductive types, called quotient inductive-inductive types (QIITs). QIITs are
of interest because there are many commonly used mathematical structures, which
can be conveniently described as QIITs in type theory, but cannot be defined as
less general inductive types, or doing so incurs large encoding overhead.

Categories are a good example. Signatures for QIITs allow having multiple sorts,
with later ones indexed over previous ones, and equations as well. We need both
features in order to write down the signature of categories:
\begin{alignat*}{3}
  & Obj && : \Set \\
  & Mor && : Obj \ra Obj \ra \Set \\
  & id  && : Mor\,i\,j \\
  & \blank\circ\blank && : Mor\,j\,k\ra Mor\,i\,j \ra Mor\,i\,k \\
  & idl && : id \circ f = f \\
  & idr && : f \circ id = f \\
  & ass && : f \circ (g \circ h) = (f \circ g) \circ h
\end{alignat*}
The benefit of having a QIIT signature is getting a model theory ``for free'',
from the metatheory of QIITs. This model theory includes a category of algebras
which has an initial object and also some additional structure. For the
signature of categories, we get the empty category as the initial object, but it
is common to consider categories with more structure, which have more
interesting initial models.

Algebraic notions of models of type theories are examples for this. Here,
initial models represent syntax, and initiality corresponds to induction on
syntax. A number of different notions have been used, from contextual categories
and comprehension categories to categories with families, but all of these are
categories with extra structure.

The main motivation of the current paper is to extend QIITs so that it
accommodates all algebraic notions of type theories which have been used in
previous works. As a beneficial side effect of fulfilling this goal, infinitary
QIITs such as Cauchy real numbers will be covered as well.

We generalize previous notions of QIITs in the following ways:
\begin{enumerate}
  \item
  \textbf{Large constructors, large elimination} and models at different
  universe levels. This feature is routinely used in the metatheory of type
  theory, but it has not been presented explicitly in previous works about
  QIITs. In order to handle universe levels gracefully, we work in an
  extensional type theory extended with cumulative universes.
  \item
  \textbf{Infinitary constructors}. This enables defining Cauchy real numbers
  and surreal numbers as QIITs. Also, the theory of QIIT signatures is itself
  large and infinitary, thus it can ``eat itself'', i.e.\ include its own
  signature and provide its own metatheory.  We use this self-representation to
  bootstrap the model theory of signatures, without having to assume any
  pre-existing internal syntax.
  \item
  \textbf{Recursive equations}, i.e. equations appearing as assumptions
  of constructors. These have occurred previously in syntaxes of cubical type
  theories, as boundary conditions.
  \item
  \textbf{Sort equations}, or equations between type constructors. They have
  been used recently to conveniently represent type-theoretic universes, for
  example Russell-style universes or cumulative hierarchies.
\end{enumerate}

We also develop semantics. We show that for each signature, there is a CwF
(category with families) of algebras, extended with $\Sigma$-types, extensional
identity, and constant families. This additional structure corresponds to a
type-theoretic flavor of finite limits, and it was shown in \cite{TODO} that the
category of such CwFs is biequivalent to the category of finitely complete
categories.

As to the existence of initial algebras, we present two different term model
constructions, yielding the following results:

\begin{enumerate}
\item
  All large infinitary QIITs with recursive equations, but \emph{without
  sort equations}, are reducible to the theory of signatures, i.e.\
  their initial algebras are constructible from the initial algebra for
  the theory of signatures.
\item
  All large finitary QIITs with sort equations, but no recursive equations,
  are reducible to the theory of signatures.
\end{enumerate}

The reason for the two separate constructions is that sort equations are not as
well-behaved as the other extensions: they are modelled as strict equalities of
sets in algebras, hence they do not respect isomorphism of sets. We make
essential use of invariance under set isomorphism in the first term model
construction, so we cannot throw sort equations into that mix.

In Section \ref{sec:levels} we set up cumulative universes which we use in later
sections. In Section \ref{sec:tos} we introduce the theory of QIIT
signatures. In Section \ref{sec:categorical_semantics} we develop initial algebra semantics,
also covering the theory of signatures itself. In Sections
\ref{sec:infinitary_term_model}-\ref{sec:sort_term} we present the two term model
constructions. We discuss related work and conclusions in Sections
\ref{sec:related}-\ref{sec:conclusion}.


\section{Cumulative Extensional Type Theory}
\label{sec:levels}

In the following sections, we will consider QIIT algebras at arbitrary finite
levels, along with large eliminations, where the initial algebra can be at a
different level than the target algebra. For a simple example, consider natural
number algebras at a given level $i$, given as the $\Sigma$-type $NatAlg_i
:\equiv(Nat : \Set_i)\times Nat\times(Nat \ra Nat)$. The initial such algebra is
the set of natural numbers, which is at level $0$, but in type theory we often
want to eliminate into larger $\Set_i$, for example when computing a
$Nat$-indexed family of types. To support convenient reasoning about levels in
this paper, we need two features: cumulativity and a way to quantify over finite
levels.

%% Universe levels are usually viewed as a bureaucratic and tedious part of type
%% theory, and are often omitted or mentioned only in passing. Here we intend to
%% model universe levels in a precise way, because large eliminations are an
%% essential part of the practical usage of inductive types. Hence, we need a way
%% to conveniently reason about levels without too much administrative
%% burden. Unfortunately, simple universe setups are insufficient for this
%% purpose. We need two features: cumulativity and a way to quantify over finite
%% levels.

\subsection{Cumulativity}

%% Cumulativity makes handling of algebras and constructions at different levels
%% much easier. For example, given an algebra $\gamma : NatAlg_i$, cumulativity
%% allows us to also have $\gamma : NatAlg_{i+j}$. In a non-cumulative setting such
%% as Agda, we may only have for each type $A : \Set_i$ a type $\mathsf{Lift}_{i\,j}\,A :
%% \Set_{i+j}$ which is isomorphic to $A$ up to definitional equality.

We need cumulativity to reduce administrative overhead. In the most basic form,
cumulativity requires that whenever $A : \Set_i$, and $i < j$ then also $A :
\Set_j$. We also need cumulativity for $\Sigma$ and function types, in order to
have cumulativity for algebras in general. For example, we want to have $\gamma
: NatAlg_j$ whenever $\gamma : NatAlg_i$ and $i < j$.

%% However, the $NatAlg$ example above also required a form of
%% cumulativity for $\Sigma$ and $\Pi$ types, which we also need in general for
%% QIIT algebras.

We use Sterling's cumulative algebraic type theory \cite{TODO} as the general
setting for the rest of the paper. The reason for this is twofold. First, it
supports the right kind of cumulativity for our purposes. Second, it is itself a
finitary QIIT with sort equations, hence this paper provides a model theory for
it\footnote{Which is, of course, somewhat circular, but not more circular than
  e.g.\ the study of models of ZFC in ZFC.}.

We extend the base theory with an extensional identity type, $\Sigma$-types and
the unit type. In \cite{TODO} a proof of canonicity is provided for the base
theory, which also includes a standard set-theoretic model. It is
straightforward to extend the canonicity proof to cover our additional type
formers.

From now on, we refer to this theory as cETT (cumulative extensional type
theory). When working in cETT, we use the following notation. We
have Russell-style universes $\Set_i$ indexed by natural numbers, dependent
functions as $(x : A)\ra B$, and dependent pairs as $(x : A)\times B$ with
projections $\proj1$ and $\proj2$. We also use a field projection notation
for iterated pairs. For example, for $t : (A : \Set_i) \times (B : \Set_i)
\times (f : A \ra B)$, we use $t.B$ to denote the projection of the second
component. Sometimes we omit the $t.$ prefix if it is clear from context.

We write propositional equality as $t = u$, with $\refl_t$ for reflexivity. We
have equality reflection for $\blank=\blank$. The unit type is $\top$, with
inhabitant $\tt$.

We also have a lifting operation on types, which introduces cumulativity.
\vspace{-1.5em}
\begin{figure}
\begin{mathpar}
  \inferrule*[lab=universe formation]
             {\\}
             {\Gamma \vdash \Set_i : \Set_{i+j+1}}

  \inferrule*[lab=function formation]
             {\Gamma \vdash A : \U_i \\ \Gamma,\,x : A \vdash B : \U_j}
             {\Gamma \vdash (x : A)\ra B : \U_{\max(i,j)} }

  \inferrule*[lab=$\Sigma$ formation]
             {\Gamma \vdash A : \U_i \\ \Gamma,\,x : A \vdash B : \U_j}
             {\Gamma \vdash (x : A)\times B : \U_{\max(i,j)} }

  \inferrule*[lab=unit formation]
             {\\}
             {\Gamma \vdash \top : \Set_i}

  \inferrule*[lab=type lifting]
             {\Gamma \vdash A : \Set_i \\ i < j}
             {\Gamma \vdash\,\Lift_j A : \Set_{j}}

  \inferrule*[lab=lift composition]{}{\Lift_j (\Lift_i A) =\,\,\Lift_{j} A}

  \inferrule*[lab=term lifting]
             {}
             {\{t\,|\,\Gamma \vdash t : A\} = \{t\,|\,\Gamma \vdash t :\,\,\Lift_i A\}}

  \inferrule*[lab=context lifting]
             {}
             {(\Gamma,\,x : A) = (\Gamma,\,x :\,\,\Lift_i A)}

  \inferrule*[lab=universe lifting]{}{\Lift_j \Set_i = \Set_i}

  \inferrule*[lab=function lifting]
             {}
             {\Lift_i((x : A)\ra B) = (x :\,\Lift_i A)\ra\,\Lift_i B}

  \inferrule*[lab=pair lifting]
             {}
             {\Lift_i((x : A)\times B) = (x :\,\Lift_i A)\,\times\Lift_i B}

  \inferrule*[lab=unit lifting]
             {}
             {\Lift_i\top = \top}
\end{mathpar}

\caption{Some of the rules for lifting.}
\label{lifting}
\end{figure}

In Figure \ref{lifting}, we include an excerpt of cETT's rules. We change
presentation slightly from Sterling. We lift from $i$ to $i+j+1$ levels instead
of assuming $i < j$ and lifting to $j$, and we use a $\U_{\max(i,j)}$ return
type in functions and pairs, instead of having both $A$, $B$ types in the same
$\Set_i$. These changed rules are all derivable from the original ones. In
general, we can expect that lifting never impedes constructions, because it
appropriately computes out of the way.

Of special note is the \emph{term lifting rule}. It is a sort equation, an
equation between sets of terms, expressing that lifted types have exactly the
same terms as unlifted ones. This allows us to have $t :\,\,\Lift_j A$ whenever $t
: A$. Together with the universe lifting rule, this implies $A : Set_{i+j+1}$
whenever $A : Set_i$. Similarly, the lifting rules for functions and pairs give
us cumulativity for $NatAlg$. We derive a notion of subtyping:

\begin{nidefinition}{Cumulative subtyping.}
  For $A : \Set_i$ and $B : \Set_{i+j+1}$, we define $A \prec B : \Set_{i+j+1}$
  as $B =\,\,\Lift_j A$.  It follows from term lifting and equality reflection
  that whenever $A \prec B$ and $t : A$, then also $t : B$.
\end{nidefinition}

\subsection{Universe Polymorphism}
\label{sec:universe_polymorphism}

We also need to quantify over universe levels. cETT does not support this, and
we leave it like that. Instead, for the sake of simplicity, we quantify over
levels in an unspecified metatheory \emph{outside} cETT. Hence, a universe
polymorphic cETT term is understood as a $\mathbb{N}$-indexed family of
terms. We use the $\forall$ symbol for this, e.g.\ as $t : \forall\,i.\,\Set_i \ra
\Set_i$. This is sufficient in this paper, because we do not need to internalize
level-polymorphic constructions in cETT.

\section{Signatures}
\label{sec:tos}

In this section, we define signatures for QIITs which support all the mentioned
generalizations. Signatures are given as contexts in a certain type theory,
called the theory of signatures. We shall abbreviate it as ToS. However, ToS
turns out to be a large infinitary QIIT itself, and we would like to define ToS
and a notion of signature without referring to QIITs, only using features
present in cETT. As a first step, we define a notion of model.

\begin{nidefinition}{Notion of model for ToS.}\label{def:tos}
For levels $i$ and $j$, there is a cETT type $\ToS_{i,j} : \Set_{\max(i,\,j)+1}$, whose elements are
ToS models (or ToS-algebras). $\ToS_{i,j}$ is an iterated $\Sigma$-type, containing
all of the following components.
\begin{enumerate}
\item
  A category with families (CwF), where all four underlying sets (of
  objects, morphisms, types and terms) are in $\Set_j$. Following notation in
  \cite{TODO}, we denote these respectively as $\Con : \Set_j$, $\Sub : \Con \ra
  \Con \ra \Set_j$, $\Ty : \Con \ra \Set_j$ and $\Tm : (\Gamma : \Con) \ra
  \Ty\,\Gamma \ra \Set_j$. We denote the empty context as $\emptycon : \Con$,
  context extension as $\blank\ext\blank : (\Gamma : \Con)\ra \Ty\,\Gamma \ra \Con$.
  Substitution on types and terms is written as $\blank[\blank]$.
\item
  A universe $\U : \Ty\,\Gamma$ with decoding $\El : (a : \Tm\,\Gamma\,\U) \ra
  \Ty\,\Gamma$.
\item
  Inductive function space, with $\Pii : (a : \Tm\,\Gamma\,\U) \ra
  \Ty\,(\Gamma\,\ext\,\El\,a) \ra \Ty\,\Gamma$ and application as $\appi :
  \Tm\,\Gamma\,(\Pii\,a\,B)\ra \Tm\,(\Gamma\,\ext\,\El\,a)\,B$. We do not
  support $\lami$ here and in other function types, as they are not essential
  for QIIT signatures.
\item
  External function space with $\Set_i$ domain: $\Pie : (A : \Set_i)\ra(A \ra
  \Ty\,\Gamma)\ra \Ty\,\Gamma$, with $\appe : \Tm\,\Gamma\,(\Pie\,A\,B)\ra(x :
  A)\ra \Tm\,\Gamma\,(B\,x)$.
\item
  Infinitary function space, with $\Piinf : (A : \Set_i)\ra(A \ra
  \Tm\,\Gamma\,\U)\ra \Tm\,\Gamma\,\U$, $\appinf :
  \Tm\,\Gamma\,(\El\,(\Pie\,A\,b))\ra(x : A)\ra \Tm\,\Gamma\,(\El\,(b\,x))$.
\item
  An identity type $\Id : (a : \Tm\,\Gamma\,\U)\ra
  \Tm\,\Gamma\,(\El\,a)\ra\Tm\,\Gamma\,(\El\,a)\ra \Tm\,\Gamma\,\U$, with
  $\Refl : (T : \Tm\,\Gamma\,(\El\,a))\ra \Id\,a\,t\,t$, equality reflection
  and uniqueness of identity proofs.
\item
  An identity type $\IdU : \Tm\,\Gamma\,\U \ra \Tm\,\Gamma\,\U \ra \Ty\,\Gamma$, with
  evident $\ReflU$, equality reflection and uniqueness of identity proofs.
\end{enumerate}
\end{nidefinition}
In the above listing, we omit most CwF components and equations for substitution and
$\beta\eta$-conversion, but these should be understood to be also part of $\ToS_{i,j}$.

\emph{Notational conventions.} CwF components by default support de Bruijn
indices, which are not easily readable. We use instead a nameful notation for
binders in context extension, $\Pii$ and $\lami$, e.g.\ as $(\emptycon \ext a :
U \ext t : \El\,a)$. We also define a type-theoretic version of $\appi$ for
convenience:
\begin{alignat*}{3}
  & \blank\appitt\blank && :
      \Tm\,\Gamma\,(\Pii\,a\,B)\ra
      (u : \Tm\,\Gamma\,(\El\,a)) \ra \Tm\,\Gamma\,(B[id, u])\\
  & t\appitt u && :\equiv (\appi\,t)[id, u]
\end{alignat*}

\begin{nidefinition}{Notion of signature.}
A QIIT signature at level $i$ is a context in an arbitrary $M : \ToS_{i,j}$
model. We define the type of such signatures as follows:
\[
  \Sig_i :\equiv \forall j.\,(M : \ToS_{i,j})\ra M.Con
\]

Note that $\Sig_i$ is defined as a universe-polymorphic type, so it does not
have a type internally to cETT.

\begin{example}
The signature for natural
numbers is the following, where $\emptycon$, $\blank\ext\blank$, $\U$, $\El$ and
$\Pii$ all refer to components of the $\lambda$-bound $M$:
\begin{alignat*}{3}
  & NatSig : \Sig_0 \\
  & NatSig :\equiv \lambda (M : \ToS_{0,j}).\,(\emptycon\,\ext\, N : \U \,\ext\, zero : \El\,N \ext suc : \Pii\,(n : N)\,(\El\,N))
\end{alignat*}
\end{example}

The $i$ level in $\Sig_i$ specifies the level of the external types appearing in
a signatures, since the $\Pie$ and $\Piinf$ function spaces have domains in $\Set_i$.
In the case of naturals numbers, no external types appear, so the level of $NatSig$
can be chosen as $0$.

With this, we are able to specify QIITs, and we can also interpret each
signature in an arbitrary ToS model, by applying a signature to a model.
$\Sig_i$ can be viewed as a precursor to a Church-encoding for the theory of
signatures, but we only need contexts encoded in this way, and not other ToS
components. In functional programming, this encoding is sometimes called
``finally tagless''\cite{TODO}, and it is used for defining and interpreting
embedded languages.
\end{nidefinition}

\subsection{Example Signatures}

Compared to signatures in the previous work \cite{TODO}, we additionally support
$\Piinf$ and $\IdU$, and $\Id$ has a more liberal type which allows recursive
equations. Let us see examples for these three in order. For brevity, we shall
only write contexts, and assume that all ToS operations come from an arbitrary
model.

\begin{example}{Infinitary constructors}. The universe $\U$ is closed under
the $\Piinf$ function type, which makes it possible to write such functions in
the domains of $\Pii$ types. This allows a signature for trees branching with
arbitrary small sets. This is a signature at level 1, since we have $\Set_0$ as
domain type.
\[
TreeSig :\equiv
\emptycon \ext Tree : \U \ext node : \Pie\,\Set_0\,\lambda A.\,\Pii\,(\Piinf\,A\,\lambda \_.\,Tree)\,(\El\,Tree)
\]
\end{example}

\begin{example}{Sort equations}. An interesting example is the term lifting
rule for cETT (omitting everything except term lifting):
\begin{alignat*}{3}
  & cETTSig :\equiv \\
  & ...\,\ext\,Tm{\Lift} : \Pii\,(\Gamma : Con)\,(\Pii\,(A : Ty{\appitt}\Gamma)((\IdU\,(Tm{\appitt}\Gamma{\appitt}A)\,(Tm{\appitt}\Gamma{\appitt}(\Lift_j{\appitt}A))))
\end{alignat*}
\end{example}

\begin{example}{Recursive equations}. Our definition of $\Id$ returns in $\U$,
which, similarly to the case of infinitary functions, allows us to write equations
in $\Pii$ domains. A minimal example:
\[
RecEqSig :\equiv \emptycon \ext A : \U \ext a : \El\,A \ext f : \Pii\,(x : A)\,(\Pii\,(\Id\,A\,x\,a)\,(\El\,A))
\]
There are more complicated and interesting examples, e.g.\ boundary conditions in
various cubical type theories\cite{TODO}. Note that our $\Id$ allows iterated
equations as well, but these are all made trivial in the semantics, where we
assume uniqueness of identity proofs.
\end{example}

\section{Categorical Semantics}
\label{sec:categorical_semantics}

For each signature, we would like to have at least
\begin{enumerate}
  \item A category of algebras, with homomorphisms as morphisms.
  \item A notion of induction, which requires a notion of dependent algebras.
  \item A proof that for algebras, initiality is equivalent to supporting induction.
\end{enumerate}

Following \cite{TODO}, we do this by creating a model of ToS, where contexts are
categories supporting the above requirements and substitutions are strictly
structure-preserving functors. Then, each signature can applied to this model,
yielding an interpretation of the signature as a structured category of
algebras. First, we fix our notion of such structured category.

\begin{nidefinition}{Finite limit CwFs.}
For a level $i$, there is a cETT type $\flCwF_i : \Set_{i+1}$, which is an
iterated $\Sigma$-type with the following components:
\begin{enumerate}
  \item A CwF with underlying sets all in $\Set_i$.
  \item $\Sigma$-type $\Sg : (A : \Ty\,\Gamma)\ra \Ty\,(\Gamma \ext A)
    \ra \Ty\,\Gamma$, with usual projections and pairing.
  \item Identity type $\Id : (A : \Ty\,\Gamma)\ra \Tm\,\Gamma\,A\ra
    \Tm\,\Gamma\,A\ra \Ty\,\Gamma$, with equality reflection and uniqueness
    of identity proofs.
  \item Constant families. This includes a type former $\Kfam : \Con \ra
    \Ty\,\Gamma$, where $\Gamma$ is implicitly quantified, and an isomorphism
    between $\Sub\,\Gamma\,\Delta$ and $\Tm\,\Gamma\,(\Kfam\,\Delta)$ which is
    natural in $\Gamma$. The idea is that $\Kfam\,\Delta$ is a representation
    of $\Delta$ as a type in any context. Dybjer and Clairambault called constant
    families ``democracy'' in \cite{TODO}.
\end{enumerate}
\end{nidefinition}

We use $\Ty$ in an flCwF to represent ``dependent objects'', and $\Tm$
for ``dependent morphisms''. We use these to define induction.

\begin{nidefinition} Notion of induction internally to $C : \flCwF_i$:
\begin{alignat*}{3}
  & Inductive : C.\Con \ra \Set_i \\
  & Inductive\,\Gamma :\equiv (A : C.\Ty\,\Gamma)\ra C.\Tm\,\Gamma\,A
\end{alignat*}
\end{nidefinition}

In the categorical semantics for a concrete signature, this informally means
that an algebra supports induction if for any dependent algebra over it (which
is a bundle of induction motives and methods), there is a dependent morphism
into it (which is a bundle of eliminator functions and their $\beta$-rules).

\begin{theorem}{Equivalence of initiality and induction.}
An object $\Gamma : C.\Con$ supports induction if and only if it is
initial. Moreover, induction and initiality are both proof irrelevant
predicates on objects.
\end{theorem}
\begin{proof} Shown by brief internal flCwF reasoning in \cite{TODO}.\qed
\end{proof}

The reason for the ``finite limit CwF'' naming is the following: Dybjer and
Clairambault showed\cite{TODO} that the 2-category of flCwFs is biequivalent to
the 2-category of finitely complete (or ``lex'') categories. It can be also seen
that the categorical product of $\Gamma$ and $\Delta$ in an flCwF can be given
as $\Gamma \ext \Kfam\, \Delta$, and equalizers can be given using the identity
type.

So, why do we use flCwF instead of lex categories? After all, the former
structure has more components and has more immediate complexity than the
latter. The reason is that flCwFs allow us to define induction in strictly the
same way as one would write it down in type theory, since we have $\Ty$ and
$\Tm$ for a primitive notion of dependent objects and morphisms. In contrast,
dependent objects in lex categories is a derived notion, and the induction
principles we get are what we want only up to isomorphisms. This issue is
perhaps not relevant from a purely categorical perspective, but we are concerned
with eventually implementing QIITs in proof assistants, so we prefer if our
semantics computes strictly.


\begin{nidefinition}{flCwF model for ToS.} We have for each $i$ and $j$ levels
an $M : \ToS_{i, 1+\max(i,j+1)}$ such that $M.\Con = \flCwF_{\max(i,j+1)}$. This
model is an extension to the CwF model of signatures in \cite{TODO}, with
$\Sigma$-types in the semantic CwF, the new type formers in signatures, and the
treatment of universe levels. We summarize the model below.
\begin{itemize}
\item As noted, $M.\Con = \flCwF_{\max(i,j+1)}$. The level $i$ marks the level of
      all external sets in function domains, and $j$ marks the level of all inductive
      sets in an algebra. Hence, every algebra, i.e.\ object of the flCwF, has
      level $\max(i,j+1)$. The bump is only needed for $j$, since algebras only contain
      \emph{elements} of $T : \Set_j$ types, while inductive sets are themselves elements
      of $\Set_i$. For example, $NatAlg_i : \Set_{\max(0, i+1)}$.
\item $\sigma : \Sub\,\Gamma\,\Delta$ substitutions are strictly structure-preserving flCwF
      functors.
    \item $A : \Ty\,\Gamma$ types are displayed flCwFs over $\Gamma$. This is an
      flCwF where every underlying set is indexed over underlying sets in
      $\Gamma$, and it is an extension of the displayed categories of Ahrens and
      Lumsdaine\cite{TODO}.  It contains equivalent data to an flCwF slice
      $\delta : \Sub\,\Delta\,\Gamma$. We prefer it to slices because it yields
      expected notions of induction strictly.
\item $t : \Tm\,\Gamma\,A$ terms are sections of the $A$ displayed flCwF. This can be viewed
      as a dependent functor, which maps structure in $\Gamma$ to corresponding displayed
      structure in $A$, e.g.\ it maps objects to displayed objects, morphisms to displayed
      morphisms, and so on.
\item $\emptycon : \Con$ is the terminal flCwF, whose underlying category is the terminal
      category with one object.

\item $\Gamma\,\ext\,A$ is the total flCwF of the $A$ displayed flCwF, where every underlying
      set is given by packing up indexed underlying sets of $A$ in $\Sigma$-s.

\item $\U : \Ty\,\Gamma$ is a displayed flCwF which is constantly (i.e. it does
      not depend on $\Gamma$) the flCwF of sets in $\Set_j$, whose underlying category
      is the usual category of sets.
\item
  $\Pii\,a\,B : \Ty\,\Gamma$ is a displayed flCwF where objects are
  dependent functions from the set of objects of $a$ to the set of objects of
  $B$. It is possible to build such flCwF because the $a : \Tm\,\Gamma\,\U$
  domain is discrete. A general $\Pii$ type is not possible because of variance
  issues; this is an extension of there being no $\Pii$ types in the category
  of categories\cite{elephant}
\item
  $\Pie\,A\,B : \Ty\,\Gamma$ is the $A$-indexed direct product of displayed flCwFs
  given by $B : A \ra \Ty\,\Gamma$.

\end{itemize}


%%   For $i$ and $j$ levels, there is
%% an $M : \ToS_{i, 1+\max(i,j+1)}$ such that $M.\Con = \flCwF_{\max(i,j+1)}$.




\end{nidefinition}





\section{Infinitary Term Models}
\label{sec:infinitary_term_models}

\subsection{Induction on Signatures}

\todo{sync}

Starting from Section \ref{sec:infinitary_term_models}, we need to do proofs and
constructions by induction on signatures. However, the current signatures do not
support induction, analogously to how induction is not available for Church
encodings. We would like to have two things: a notion of signature induction,
and a model of ToS which supports induction. Then, we can use contexts in the
syntax of ToS (i.e.\ in the inductive model) as signatures. We provide a notion
of induction on signatures by
\begin{enumerate}
  \item Showing that there is a signature which describes ToS.
  \item Building categorical semantics, which for each signature provides a notion of induction.
\end{enumerate}
On the other hand, in this paper we will only \emph{assume} the existence of a
syntax for ToS starting from Section \ref{sec:infinitary_term_models}. We do not provide a
construction of the syntax from simpler type formers, although we do show that
lower-level ToS syntaxes are constructible from higher-level ones.

\subsection{Preservation of Isomorphisms}

\section{Term Models with Sort Equations}
\label{sec:sort_term}

\section{Related Work}
\label{sec:related}

\section{Conclusion}
\label{sec:conclusion}


\bibliography{references}

\end{document}
